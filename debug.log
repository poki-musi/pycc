Grammar:

Rule 0     S' -> S
Rule 1     S -> S_
Rule 2     S_ -> <empty>
Rule 3     S_ -> S_ toplevel_stmt
Rule 4     toplevel_stmt -> global_var
Rule 5     toplevel_stmt -> fun_def
Rule 6     toplevel_stmt -> fun_decl
Rule 7     global_var -> type var_decl_ ;
Rule 8     fun_def -> fun { body }
Rule 9     fun_decl -> fun ;
Rule 10    fun -> type decl_ptrs ID ( fun_args )
Rule 11    fun_args -> <empty>
Rule 12    fun_args -> fun_args_
Rule 13    fun_args_ -> type decl_ptrs ID
Rule 14    fun_args_ -> fun_args_ , type decl_ptrs ID
Rule 15    body -> <empty>
Rule 16    body -> body stmt
Rule 17    stmt -> for_stmt
Rule 18    stmt -> continue_stmt
Rule 19    stmt -> break_stmt
Rule 20    stmt -> while_stmt
Rule 21    stmt -> block_stmt
Rule 22    stmt -> if_stmt
Rule 23    stmt -> return_stmt
Rule 24    stmt -> var_decl
Rule 25    stmt -> exp_stmt
Rule 26    while_stmt -> KW_WHILE ( exp ) block_stmt
Rule 27    break_stmt -> KW_BREAK ;
Rule 28    continue_stmt -> KW_CONTINUE ;
Rule 29    for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt
Rule 30    for_decl -> ;
Rule 31    for_decl -> stmt
Rule 32    for_cond -> ;
Rule 33    for_cond -> exp ;
Rule 34    for_exp -> <empty>
Rule 35    for_exp -> exp
Rule 36    if_stmt -> KW_IF ( exp ) block_stmt else_stmt
Rule 37    else_stmt -> <empty>
Rule 38    else_stmt -> KW_ELSE if_stmt
Rule 39    else_stmt -> KW_ELSE block_stmt
Rule 40    exp_stmt -> exp ;
Rule 41    return_stmt -> KW_RETURN exp ;
Rule 42    return_stmt -> KW_RETURN ;
Rule 43    block_stmt -> { body }
Rule 44    var_decl -> is_static type var_decl_ ;
Rule 45    is_static -> <empty>
Rule 46    is_static -> KW_STATIC
Rule 47    var_decl_ -> param_decl
Rule 48    var_decl_ -> var_decl_ , param_decl
Rule 49    param_decl -> decl_ptrs ID array_idxs var_decl_exp
Rule 50    decl_ptrs -> <empty>
Rule 51    decl_ptrs -> decl_ptrs *
Rule 52    var_decl_exp -> = exp
Rule 53    var_decl_exp -> = array
Rule 54    var_decl_exp -> <empty>
Rule 55    array_idxs -> <empty>
Rule 56    array_idxs -> array_idxs [ NUM ]
Rule 57    array -> { array_base }
Rule 58    array -> { array_rec }
Rule 59    array_rec -> array
Rule 60    array_rec -> array_rec , array
Rule 61    array_base -> exp
Rule 62    array_base -> array_base , exp
Rule 63    exp -> assign
Rule 64    assign -> or_exp
Rule 65    assign -> unary = assign
Rule 66    or_exp -> and_exp
Rule 67    or_exp -> or_exp OR and_exp
Rule 68    and_exp -> or_bin
Rule 69    and_exp -> and_exp AND or_bin
Rule 70    or_bin -> xor_bin ^ and_bin
Rule 71    or_bin -> or_bin | xor_bin
Rule 72    xor_bin -> and_bin
Rule 73    xor_bin -> xor_bin
Rule 74    and_bin -> comp_exp
Rule 75    and_bin -> and_bin & comp_exp
Rule 76    comp_exp -> sum
Rule 77    comp_exp -> sum < comp_exp
Rule 78    comp_exp -> sum > comp_exp
Rule 79    comp_exp -> sum GREATER_EQ comp_exp
Rule 80    comp_exp -> sum LESSER_EQ comp_exp
Rule 81    comp_exp -> sum NOT_EQ comp_exp
Rule 82    comp_exp -> sum EQ_EQ comp_exp
Rule 83    sum -> prod
Rule 84    sum -> sum - prod
Rule 85    sum -> sum + prod
Rule 86    prod -> shiftop
Rule 87    prod -> prod / shiftop
Rule 88    prod -> prod * shiftop
Rule 89    shiftop -> unary
Rule 90    shiftop -> shiftop SHIFT_L unary
Rule 91    shiftop -> shiftop SHIFT_R unary
Rule 92    unary -> call
Rule 93    unary -> ( type_lit ) unary
Rule 94    unary -> ~ unary
Rule 95    unary -> & unary
Rule 96    unary -> * unary
Rule 97    unary -> - unary
Rule 98    unary -> ! unary
Rule 99    call -> atom
Rule 100   call -> call [ exp ]
Rule 101   call -> ID ( call_args )
Rule 102   call_args -> call_args_
Rule 103   call_args -> <empty>
Rule 104   call_args_ -> exp
Rule 105   call_args_ -> call_args_ , exp
Rule 106   atom -> STR
Rule 107   atom -> NUM_LIT
Rule 108   atom -> NUM
Rule 109   atom -> ID
Rule 110   atom -> KW_SIZEOF ( type_lit )
Rule 111   atom -> KW_SIZEOF ( exp )
Rule 112   atom -> ( exp )
Rule 113   type_lit -> type_lit_ptr
Rule 114   type_lit -> type_lit [ NUM ]
Rule 115   type_lit_ptr -> type
Rule 116   type_lit_ptr -> type_lit_ptr *
Rule 117   type -> KW_VOID
Rule 118   type -> KW_INT

Terminals, with rules where they appear:

!                    : 98
&                    : 75 95
(                    : 10 26 29 36 93 101 110 111 112
)                    : 10 26 29 36 93 101 110 111 112
*                    : 51 88 96 116
+                    : 85
,                    : 14 48 60 62 105
-                    : 84 97
/                    : 87
;                    : 7 9 27 28 30 32 33 40 41 42 44
<                    : 77
=                    : 52 53 65
>                    : 78
AND                  : 69
EQ_EQ                : 82
GREATER_EQ           : 79
ID                   : 10 13 14 49 101 109
KW_BREAK             : 27
KW_CONTINUE          : 28
KW_ELSE              : 38 39
KW_FOR               : 29
KW_IF                : 36
KW_INT               : 118
KW_RETURN            : 41 42
KW_SIZEOF            : 110 111
KW_STATIC            : 46
KW_VOID              : 117
KW_WHILE             : 26
LESSER_EQ            : 80
NOT_EQ               : 81
NUM                  : 56 108 114
NUM_LIT              : 107
OR                   : 67
SHIFT_L              : 90
SHIFT_R              : 91
STR                  : 106
[                    : 56 100 114
]                    : 56 100 114
^                    : 70
error                :
{                    : 8 43 57 58
|                    : 71
}                    : 8 43 57 58
~                    : 94

Nonterminals, with rules where they appear:

S                    : 0
S_                   : 1 3
and_bin              : 70 72 75
and_exp              : 66 67 69
array                : 53 59 60
array_base           : 57 62
array_idxs           : 49 56
array_rec            : 58 60
assign               : 63 65
atom                 : 99
block_stmt           : 21 26 29 36 39
body                 : 8 16 43
break_stmt           : 19
call                 : 92 100
call_args            : 101
call_args_           : 102 105
comp_exp             : 74 75 77 78 79 80 81 82
continue_stmt        : 18
decl_ptrs            : 10 13 14 49 51
else_stmt            : 36
exp                  : 26 33 35 36 40 41 52 61 62 100 104 105 111 112
exp_stmt             : 25
for_cond             : 29
for_decl             : 29
for_exp              : 29
for_stmt             : 17
fun                  : 8 9
fun_args             : 10
fun_args_            : 12 14
fun_decl             : 6
fun_def              : 5
global_var           : 4
if_stmt              : 22 38
is_static            : 44
or_bin               : 68 69 71
or_exp               : 64 67
param_decl           : 47 48
prod                 : 83 84 85 87 88
return_stmt          : 23
shiftop              : 86 87 88 90 91
stmt                 : 16 31
sum                  : 76 77 78 79 80 81 82 84 85
toplevel_stmt        : 3
type                 : 7 10 13 14 44 115
type_lit             : 93 110 114
type_lit_ptr         : 113 116
unary                : 65 89 90 91 93 94 95 96 97 98
var_decl             : 24
var_decl_            : 7 44 48
var_decl_exp         : 49
while_stmt           : 20
xor_bin              : 70 71 73


state 0

    (0) S' -> . S
    (1) S -> . S_
    (2) S_ -> .
    (3) S_ -> . S_ toplevel_stmt
    KW_VOID         reduce using rule 2 (S_ -> .)
    KW_INT          reduce using rule 2 (S_ -> .)
    $end            reduce using rule 2 (S_ -> .)

    S                              shift and go to state 1
    S_                             shift and go to state 2

state 1

    (0) S' -> S .


state 2

    (1) S -> S_ .
    (3) S_ -> S_ . toplevel_stmt
    (4) toplevel_stmt -> . global_var
    (5) toplevel_stmt -> . fun_def
    (6) toplevel_stmt -> . fun_decl
    (7) global_var -> . type var_decl_ ;
    (8) fun_def -> . fun { body }
    (9) fun_decl -> . fun ;
    (117) type -> . KW_VOID
    (118) type -> . KW_INT
    (10) fun -> . type decl_ptrs ID ( fun_args )
    $end            reduce using rule 1 (S -> S_ .)
    KW_VOID         shift and go to state 9
    KW_INT          shift and go to state 10

    toplevel_stmt                  shift and go to state 3
    global_var                     shift and go to state 4
    fun_def                        shift and go to state 5
    fun_decl                       shift and go to state 6
    type                           shift and go to state 7
    fun                            shift and go to state 8

state 3

    (3) S_ -> S_ toplevel_stmt .
    KW_VOID         reduce using rule 3 (S_ -> S_ toplevel_stmt .)
    KW_INT          reduce using rule 3 (S_ -> S_ toplevel_stmt .)
    $end            reduce using rule 3 (S_ -> S_ toplevel_stmt .)


state 4

    (4) toplevel_stmt -> global_var .
    KW_VOID         reduce using rule 4 (toplevel_stmt -> global_var .)
    KW_INT          reduce using rule 4 (toplevel_stmt -> global_var .)
    $end            reduce using rule 4 (toplevel_stmt -> global_var .)


state 5

    (5) toplevel_stmt -> fun_def .
    KW_VOID         reduce using rule 5 (toplevel_stmt -> fun_def .)
    KW_INT          reduce using rule 5 (toplevel_stmt -> fun_def .)
    $end            reduce using rule 5 (toplevel_stmt -> fun_def .)


state 6

    (6) toplevel_stmt -> fun_decl .
    KW_VOID         reduce using rule 6 (toplevel_stmt -> fun_decl .)
    KW_INT          reduce using rule 6 (toplevel_stmt -> fun_decl .)
    $end            reduce using rule 6 (toplevel_stmt -> fun_decl .)


state 7

    (7) global_var -> type . var_decl_ ;
    (10) fun -> type . decl_ptrs ID ( fun_args )
    (47) var_decl_ -> . param_decl
    (48) var_decl_ -> . var_decl_ , param_decl
    (50) decl_ptrs -> .
    (51) decl_ptrs -> . decl_ptrs *
    (49) param_decl -> . decl_ptrs ID array_idxs var_decl_exp
    ID              reduce using rule 50 (decl_ptrs -> .)
    *               reduce using rule 50 (decl_ptrs -> .)

    var_decl_                      shift and go to state 11
    decl_ptrs                      shift and go to state 12
    param_decl                     shift and go to state 13

state 8

    (8) fun_def -> fun . { body }
    (9) fun_decl -> fun . ;
    {               shift and go to state 14
    ;               shift and go to state 15


state 9

    (117) type -> KW_VOID .
    ID              reduce using rule 117 (type -> KW_VOID .)
    *               reduce using rule 117 (type -> KW_VOID .)
    )               reduce using rule 117 (type -> KW_VOID .)
    [               reduce using rule 117 (type -> KW_VOID .)


state 10

    (118) type -> KW_INT .
    ID              reduce using rule 118 (type -> KW_INT .)
    *               reduce using rule 118 (type -> KW_INT .)
    )               reduce using rule 118 (type -> KW_INT .)
    [               reduce using rule 118 (type -> KW_INT .)


state 11

    (7) global_var -> type var_decl_ . ;
    (48) var_decl_ -> var_decl_ . , param_decl
    ;               shift and go to state 16
    ,               shift and go to state 17


state 12

    (10) fun -> type decl_ptrs . ID ( fun_args )
    (51) decl_ptrs -> decl_ptrs . *
    (49) param_decl -> decl_ptrs . ID array_idxs var_decl_exp
    ID              shift and go to state 18
    *               shift and go to state 19


state 13

    (47) var_decl_ -> param_decl .
    ;               reduce using rule 47 (var_decl_ -> param_decl .)
    ,               reduce using rule 47 (var_decl_ -> param_decl .)


state 14

    (8) fun_def -> fun { . body }
    (15) body -> .
    (16) body -> . body stmt
    }               reduce using rule 15 (body -> .)
    KW_FOR          reduce using rule 15 (body -> .)
    KW_CONTINUE     reduce using rule 15 (body -> .)
    KW_BREAK        reduce using rule 15 (body -> .)
    KW_WHILE        reduce using rule 15 (body -> .)
    {               reduce using rule 15 (body -> .)
    KW_IF           reduce using rule 15 (body -> .)
    KW_RETURN       reduce using rule 15 (body -> .)
    KW_STATIC       reduce using rule 15 (body -> .)
    (               reduce using rule 15 (body -> .)
    ~               reduce using rule 15 (body -> .)
    &               reduce using rule 15 (body -> .)
    *               reduce using rule 15 (body -> .)
    -               reduce using rule 15 (body -> .)
    !               reduce using rule 15 (body -> .)
    ID              reduce using rule 15 (body -> .)
    STR             reduce using rule 15 (body -> .)
    NUM_LIT         reduce using rule 15 (body -> .)
    NUM             reduce using rule 15 (body -> .)
    KW_SIZEOF       reduce using rule 15 (body -> .)
    KW_VOID         reduce using rule 15 (body -> .)
    KW_INT          reduce using rule 15 (body -> .)

    body                           shift and go to state 20

state 15

    (9) fun_decl -> fun ; .
    KW_VOID         reduce using rule 9 (fun_decl -> fun ; .)
    KW_INT          reduce using rule 9 (fun_decl -> fun ; .)
    $end            reduce using rule 9 (fun_decl -> fun ; .)


state 16

    (7) global_var -> type var_decl_ ; .
    KW_VOID         reduce using rule 7 (global_var -> type var_decl_ ; .)
    KW_INT          reduce using rule 7 (global_var -> type var_decl_ ; .)
    $end            reduce using rule 7 (global_var -> type var_decl_ ; .)


state 17

    (48) var_decl_ -> var_decl_ , . param_decl
    (49) param_decl -> . decl_ptrs ID array_idxs var_decl_exp
    (50) decl_ptrs -> .
    (51) decl_ptrs -> . decl_ptrs *
    ID              reduce using rule 50 (decl_ptrs -> .)
    *               reduce using rule 50 (decl_ptrs -> .)

    param_decl                     shift and go to state 21
    decl_ptrs                      shift and go to state 22

state 18

    (10) fun -> type decl_ptrs ID . ( fun_args )
    (49) param_decl -> decl_ptrs ID . array_idxs var_decl_exp
    (55) array_idxs -> .
    (56) array_idxs -> . array_idxs [ NUM ]
    (               shift and go to state 23
    [               reduce using rule 55 (array_idxs -> .)
    =               reduce using rule 55 (array_idxs -> .)
    ;               reduce using rule 55 (array_idxs -> .)
    ,               reduce using rule 55 (array_idxs -> .)

    array_idxs                     shift and go to state 24

state 19

    (51) decl_ptrs -> decl_ptrs * .
    ID              reduce using rule 51 (decl_ptrs -> decl_ptrs * .)
    *               reduce using rule 51 (decl_ptrs -> decl_ptrs * .)


state 20

    (8) fun_def -> fun { body . }
    (16) body -> body . stmt
    (17) stmt -> . for_stmt
    (18) stmt -> . continue_stmt
    (19) stmt -> . break_stmt
    (20) stmt -> . while_stmt
    (21) stmt -> . block_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . return_stmt
    (24) stmt -> . var_decl
    (25) stmt -> . exp_stmt
    (29) for_stmt -> . KW_FOR ( for_decl for_cond for_exp ) block_stmt
    (28) continue_stmt -> . KW_CONTINUE ;
    (27) break_stmt -> . KW_BREAK ;
    (26) while_stmt -> . KW_WHILE ( exp ) block_stmt
    (43) block_stmt -> . { body }
    (36) if_stmt -> . KW_IF ( exp ) block_stmt else_stmt
    (41) return_stmt -> . KW_RETURN exp ;
    (42) return_stmt -> . KW_RETURN ;
    (44) var_decl -> . is_static type var_decl_ ;
    (40) exp_stmt -> . exp ;
    (45) is_static -> .
    (46) is_static -> . KW_STATIC
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    }               shift and go to state 26
    KW_FOR          shift and go to state 37
    KW_CONTINUE     shift and go to state 39
    KW_BREAK        shift and go to state 40
    KW_WHILE        shift and go to state 41
    {               shift and go to state 25
    KW_IF           shift and go to state 43
    KW_RETURN       shift and go to state 44
    KW_VOID         reduce using rule 45 (is_static -> .)
    KW_INT          reduce using rule 45 (is_static -> .)
    KW_STATIC       shift and go to state 46
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    stmt                           shift and go to state 27
    for_stmt                       shift and go to state 28
    continue_stmt                  shift and go to state 29
    break_stmt                     shift and go to state 30
    while_stmt                     shift and go to state 31
    block_stmt                     shift and go to state 32
    if_stmt                        shift and go to state 33
    return_stmt                    shift and go to state 34
    var_decl                       shift and go to state 35
    exp_stmt                       shift and go to state 36
    exp                            shift and go to state 42
    is_static                      shift and go to state 45
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 21

    (48) var_decl_ -> var_decl_ , param_decl .
    ;               reduce using rule 48 (var_decl_ -> var_decl_ , param_decl .)
    ,               reduce using rule 48 (var_decl_ -> var_decl_ , param_decl .)


state 22

    (49) param_decl -> decl_ptrs . ID array_idxs var_decl_exp
    (51) decl_ptrs -> decl_ptrs . *
    ID              shift and go to state 70
    *               shift and go to state 19


state 23

    (10) fun -> type decl_ptrs ID ( . fun_args )
    (11) fun_args -> .
    (12) fun_args -> . fun_args_
    (13) fun_args_ -> . type decl_ptrs ID
    (14) fun_args_ -> . fun_args_ , type decl_ptrs ID
    (117) type -> . KW_VOID
    (118) type -> . KW_INT
    )               reduce using rule 11 (fun_args -> .)
    KW_VOID         shift and go to state 9
    KW_INT          shift and go to state 10

    type                           shift and go to state 71
    fun_args                       shift and go to state 72
    fun_args_                      shift and go to state 73

state 24

    (49) param_decl -> decl_ptrs ID array_idxs . var_decl_exp
    (56) array_idxs -> array_idxs . [ NUM ]
    (52) var_decl_exp -> . = exp
    (53) var_decl_exp -> . = array
    (54) var_decl_exp -> .
    [               shift and go to state 75
    =               shift and go to state 76
    ;               reduce using rule 54 (var_decl_exp -> .)
    ,               reduce using rule 54 (var_decl_exp -> .)

    var_decl_exp                   shift and go to state 74

state 25

    (43) block_stmt -> { . body }
    (15) body -> .
    (16) body -> . body stmt
    }               reduce using rule 15 (body -> .)
    KW_FOR          reduce using rule 15 (body -> .)
    KW_CONTINUE     reduce using rule 15 (body -> .)
    KW_BREAK        reduce using rule 15 (body -> .)
    KW_WHILE        reduce using rule 15 (body -> .)
    {               reduce using rule 15 (body -> .)
    KW_IF           reduce using rule 15 (body -> .)
    KW_RETURN       reduce using rule 15 (body -> .)
    KW_STATIC       reduce using rule 15 (body -> .)
    (               reduce using rule 15 (body -> .)
    ~               reduce using rule 15 (body -> .)
    &               reduce using rule 15 (body -> .)
    *               reduce using rule 15 (body -> .)
    -               reduce using rule 15 (body -> .)
    !               reduce using rule 15 (body -> .)
    ID              reduce using rule 15 (body -> .)
    STR             reduce using rule 15 (body -> .)
    NUM_LIT         reduce using rule 15 (body -> .)
    NUM             reduce using rule 15 (body -> .)
    KW_SIZEOF       reduce using rule 15 (body -> .)
    KW_VOID         reduce using rule 15 (body -> .)
    KW_INT          reduce using rule 15 (body -> .)

    body                           shift and go to state 77

state 26

    (8) fun_def -> fun { body } .
    KW_VOID         reduce using rule 8 (fun_def -> fun { body } .)
    KW_INT          reduce using rule 8 (fun_def -> fun { body } .)
    $end            reduce using rule 8 (fun_def -> fun { body } .)


state 27

    (16) body -> body stmt .
    }               reduce using rule 16 (body -> body stmt .)
    KW_FOR          reduce using rule 16 (body -> body stmt .)
    KW_CONTINUE     reduce using rule 16 (body -> body stmt .)
    KW_BREAK        reduce using rule 16 (body -> body stmt .)
    KW_WHILE        reduce using rule 16 (body -> body stmt .)
    {               reduce using rule 16 (body -> body stmt .)
    KW_IF           reduce using rule 16 (body -> body stmt .)
    KW_RETURN       reduce using rule 16 (body -> body stmt .)
    KW_STATIC       reduce using rule 16 (body -> body stmt .)
    (               reduce using rule 16 (body -> body stmt .)
    ~               reduce using rule 16 (body -> body stmt .)
    &               reduce using rule 16 (body -> body stmt .)
    *               reduce using rule 16 (body -> body stmt .)
    -               reduce using rule 16 (body -> body stmt .)
    !               reduce using rule 16 (body -> body stmt .)
    ID              reduce using rule 16 (body -> body stmt .)
    STR             reduce using rule 16 (body -> body stmt .)
    NUM_LIT         reduce using rule 16 (body -> body stmt .)
    NUM             reduce using rule 16 (body -> body stmt .)
    KW_SIZEOF       reduce using rule 16 (body -> body stmt .)
    KW_VOID         reduce using rule 16 (body -> body stmt .)
    KW_INT          reduce using rule 16 (body -> body stmt .)


state 28

    (17) stmt -> for_stmt .
    }               reduce using rule 17 (stmt -> for_stmt .)
    KW_FOR          reduce using rule 17 (stmt -> for_stmt .)
    KW_CONTINUE     reduce using rule 17 (stmt -> for_stmt .)
    KW_BREAK        reduce using rule 17 (stmt -> for_stmt .)
    KW_WHILE        reduce using rule 17 (stmt -> for_stmt .)
    {               reduce using rule 17 (stmt -> for_stmt .)
    KW_IF           reduce using rule 17 (stmt -> for_stmt .)
    KW_RETURN       reduce using rule 17 (stmt -> for_stmt .)
    KW_STATIC       reduce using rule 17 (stmt -> for_stmt .)
    (               reduce using rule 17 (stmt -> for_stmt .)
    ~               reduce using rule 17 (stmt -> for_stmt .)
    &               reduce using rule 17 (stmt -> for_stmt .)
    *               reduce using rule 17 (stmt -> for_stmt .)
    -               reduce using rule 17 (stmt -> for_stmt .)
    !               reduce using rule 17 (stmt -> for_stmt .)
    ID              reduce using rule 17 (stmt -> for_stmt .)
    STR             reduce using rule 17 (stmt -> for_stmt .)
    NUM_LIT         reduce using rule 17 (stmt -> for_stmt .)
    NUM             reduce using rule 17 (stmt -> for_stmt .)
    KW_SIZEOF       reduce using rule 17 (stmt -> for_stmt .)
    KW_VOID         reduce using rule 17 (stmt -> for_stmt .)
    KW_INT          reduce using rule 17 (stmt -> for_stmt .)
    ;               reduce using rule 17 (stmt -> for_stmt .)


state 29

    (18) stmt -> continue_stmt .
    }               reduce using rule 18 (stmt -> continue_stmt .)
    KW_FOR          reduce using rule 18 (stmt -> continue_stmt .)
    KW_CONTINUE     reduce using rule 18 (stmt -> continue_stmt .)
    KW_BREAK        reduce using rule 18 (stmt -> continue_stmt .)
    KW_WHILE        reduce using rule 18 (stmt -> continue_stmt .)
    {               reduce using rule 18 (stmt -> continue_stmt .)
    KW_IF           reduce using rule 18 (stmt -> continue_stmt .)
    KW_RETURN       reduce using rule 18 (stmt -> continue_stmt .)
    KW_STATIC       reduce using rule 18 (stmt -> continue_stmt .)
    (               reduce using rule 18 (stmt -> continue_stmt .)
    ~               reduce using rule 18 (stmt -> continue_stmt .)
    &               reduce using rule 18 (stmt -> continue_stmt .)
    *               reduce using rule 18 (stmt -> continue_stmt .)
    -               reduce using rule 18 (stmt -> continue_stmt .)
    !               reduce using rule 18 (stmt -> continue_stmt .)
    ID              reduce using rule 18 (stmt -> continue_stmt .)
    STR             reduce using rule 18 (stmt -> continue_stmt .)
    NUM_LIT         reduce using rule 18 (stmt -> continue_stmt .)
    NUM             reduce using rule 18 (stmt -> continue_stmt .)
    KW_SIZEOF       reduce using rule 18 (stmt -> continue_stmt .)
    KW_VOID         reduce using rule 18 (stmt -> continue_stmt .)
    KW_INT          reduce using rule 18 (stmt -> continue_stmt .)
    ;               reduce using rule 18 (stmt -> continue_stmt .)


state 30

    (19) stmt -> break_stmt .
    }               reduce using rule 19 (stmt -> break_stmt .)
    KW_FOR          reduce using rule 19 (stmt -> break_stmt .)
    KW_CONTINUE     reduce using rule 19 (stmt -> break_stmt .)
    KW_BREAK        reduce using rule 19 (stmt -> break_stmt .)
    KW_WHILE        reduce using rule 19 (stmt -> break_stmt .)
    {               reduce using rule 19 (stmt -> break_stmt .)
    KW_IF           reduce using rule 19 (stmt -> break_stmt .)
    KW_RETURN       reduce using rule 19 (stmt -> break_stmt .)
    KW_STATIC       reduce using rule 19 (stmt -> break_stmt .)
    (               reduce using rule 19 (stmt -> break_stmt .)
    ~               reduce using rule 19 (stmt -> break_stmt .)
    &               reduce using rule 19 (stmt -> break_stmt .)
    *               reduce using rule 19 (stmt -> break_stmt .)
    -               reduce using rule 19 (stmt -> break_stmt .)
    !               reduce using rule 19 (stmt -> break_stmt .)
    ID              reduce using rule 19 (stmt -> break_stmt .)
    STR             reduce using rule 19 (stmt -> break_stmt .)
    NUM_LIT         reduce using rule 19 (stmt -> break_stmt .)
    NUM             reduce using rule 19 (stmt -> break_stmt .)
    KW_SIZEOF       reduce using rule 19 (stmt -> break_stmt .)
    KW_VOID         reduce using rule 19 (stmt -> break_stmt .)
    KW_INT          reduce using rule 19 (stmt -> break_stmt .)
    ;               reduce using rule 19 (stmt -> break_stmt .)


state 31

    (20) stmt -> while_stmt .
    }               reduce using rule 20 (stmt -> while_stmt .)
    KW_FOR          reduce using rule 20 (stmt -> while_stmt .)
    KW_CONTINUE     reduce using rule 20 (stmt -> while_stmt .)
    KW_BREAK        reduce using rule 20 (stmt -> while_stmt .)
    KW_WHILE        reduce using rule 20 (stmt -> while_stmt .)
    {               reduce using rule 20 (stmt -> while_stmt .)
    KW_IF           reduce using rule 20 (stmt -> while_stmt .)
    KW_RETURN       reduce using rule 20 (stmt -> while_stmt .)
    KW_STATIC       reduce using rule 20 (stmt -> while_stmt .)
    (               reduce using rule 20 (stmt -> while_stmt .)
    ~               reduce using rule 20 (stmt -> while_stmt .)
    &               reduce using rule 20 (stmt -> while_stmt .)
    *               reduce using rule 20 (stmt -> while_stmt .)
    -               reduce using rule 20 (stmt -> while_stmt .)
    !               reduce using rule 20 (stmt -> while_stmt .)
    ID              reduce using rule 20 (stmt -> while_stmt .)
    STR             reduce using rule 20 (stmt -> while_stmt .)
    NUM_LIT         reduce using rule 20 (stmt -> while_stmt .)
    NUM             reduce using rule 20 (stmt -> while_stmt .)
    KW_SIZEOF       reduce using rule 20 (stmt -> while_stmt .)
    KW_VOID         reduce using rule 20 (stmt -> while_stmt .)
    KW_INT          reduce using rule 20 (stmt -> while_stmt .)
    ;               reduce using rule 20 (stmt -> while_stmt .)


state 32

    (21) stmt -> block_stmt .
    }               reduce using rule 21 (stmt -> block_stmt .)
    KW_FOR          reduce using rule 21 (stmt -> block_stmt .)
    KW_CONTINUE     reduce using rule 21 (stmt -> block_stmt .)
    KW_BREAK        reduce using rule 21 (stmt -> block_stmt .)
    KW_WHILE        reduce using rule 21 (stmt -> block_stmt .)
    {               reduce using rule 21 (stmt -> block_stmt .)
    KW_IF           reduce using rule 21 (stmt -> block_stmt .)
    KW_RETURN       reduce using rule 21 (stmt -> block_stmt .)
    KW_STATIC       reduce using rule 21 (stmt -> block_stmt .)
    (               reduce using rule 21 (stmt -> block_stmt .)
    ~               reduce using rule 21 (stmt -> block_stmt .)
    &               reduce using rule 21 (stmt -> block_stmt .)
    *               reduce using rule 21 (stmt -> block_stmt .)
    -               reduce using rule 21 (stmt -> block_stmt .)
    !               reduce using rule 21 (stmt -> block_stmt .)
    ID              reduce using rule 21 (stmt -> block_stmt .)
    STR             reduce using rule 21 (stmt -> block_stmt .)
    NUM_LIT         reduce using rule 21 (stmt -> block_stmt .)
    NUM             reduce using rule 21 (stmt -> block_stmt .)
    KW_SIZEOF       reduce using rule 21 (stmt -> block_stmt .)
    KW_VOID         reduce using rule 21 (stmt -> block_stmt .)
    KW_INT          reduce using rule 21 (stmt -> block_stmt .)
    ;               reduce using rule 21 (stmt -> block_stmt .)


state 33

    (22) stmt -> if_stmt .
    }               reduce using rule 22 (stmt -> if_stmt .)
    KW_FOR          reduce using rule 22 (stmt -> if_stmt .)
    KW_CONTINUE     reduce using rule 22 (stmt -> if_stmt .)
    KW_BREAK        reduce using rule 22 (stmt -> if_stmt .)
    KW_WHILE        reduce using rule 22 (stmt -> if_stmt .)
    {               reduce using rule 22 (stmt -> if_stmt .)
    KW_IF           reduce using rule 22 (stmt -> if_stmt .)
    KW_RETURN       reduce using rule 22 (stmt -> if_stmt .)
    KW_STATIC       reduce using rule 22 (stmt -> if_stmt .)
    (               reduce using rule 22 (stmt -> if_stmt .)
    ~               reduce using rule 22 (stmt -> if_stmt .)
    &               reduce using rule 22 (stmt -> if_stmt .)
    *               reduce using rule 22 (stmt -> if_stmt .)
    -               reduce using rule 22 (stmt -> if_stmt .)
    !               reduce using rule 22 (stmt -> if_stmt .)
    ID              reduce using rule 22 (stmt -> if_stmt .)
    STR             reduce using rule 22 (stmt -> if_stmt .)
    NUM_LIT         reduce using rule 22 (stmt -> if_stmt .)
    NUM             reduce using rule 22 (stmt -> if_stmt .)
    KW_SIZEOF       reduce using rule 22 (stmt -> if_stmt .)
    KW_VOID         reduce using rule 22 (stmt -> if_stmt .)
    KW_INT          reduce using rule 22 (stmt -> if_stmt .)
    ;               reduce using rule 22 (stmt -> if_stmt .)


state 34

    (23) stmt -> return_stmt .
    }               reduce using rule 23 (stmt -> return_stmt .)
    KW_FOR          reduce using rule 23 (stmt -> return_stmt .)
    KW_CONTINUE     reduce using rule 23 (stmt -> return_stmt .)
    KW_BREAK        reduce using rule 23 (stmt -> return_stmt .)
    KW_WHILE        reduce using rule 23 (stmt -> return_stmt .)
    {               reduce using rule 23 (stmt -> return_stmt .)
    KW_IF           reduce using rule 23 (stmt -> return_stmt .)
    KW_RETURN       reduce using rule 23 (stmt -> return_stmt .)
    KW_STATIC       reduce using rule 23 (stmt -> return_stmt .)
    (               reduce using rule 23 (stmt -> return_stmt .)
    ~               reduce using rule 23 (stmt -> return_stmt .)
    &               reduce using rule 23 (stmt -> return_stmt .)
    *               reduce using rule 23 (stmt -> return_stmt .)
    -               reduce using rule 23 (stmt -> return_stmt .)
    !               reduce using rule 23 (stmt -> return_stmt .)
    ID              reduce using rule 23 (stmt -> return_stmt .)
    STR             reduce using rule 23 (stmt -> return_stmt .)
    NUM_LIT         reduce using rule 23 (stmt -> return_stmt .)
    NUM             reduce using rule 23 (stmt -> return_stmt .)
    KW_SIZEOF       reduce using rule 23 (stmt -> return_stmt .)
    KW_VOID         reduce using rule 23 (stmt -> return_stmt .)
    KW_INT          reduce using rule 23 (stmt -> return_stmt .)
    ;               reduce using rule 23 (stmt -> return_stmt .)


state 35

    (24) stmt -> var_decl .
    }               reduce using rule 24 (stmt -> var_decl .)
    KW_FOR          reduce using rule 24 (stmt -> var_decl .)
    KW_CONTINUE     reduce using rule 24 (stmt -> var_decl .)
    KW_BREAK        reduce using rule 24 (stmt -> var_decl .)
    KW_WHILE        reduce using rule 24 (stmt -> var_decl .)
    {               reduce using rule 24 (stmt -> var_decl .)
    KW_IF           reduce using rule 24 (stmt -> var_decl .)
    KW_RETURN       reduce using rule 24 (stmt -> var_decl .)
    KW_STATIC       reduce using rule 24 (stmt -> var_decl .)
    (               reduce using rule 24 (stmt -> var_decl .)
    ~               reduce using rule 24 (stmt -> var_decl .)
    &               reduce using rule 24 (stmt -> var_decl .)
    *               reduce using rule 24 (stmt -> var_decl .)
    -               reduce using rule 24 (stmt -> var_decl .)
    !               reduce using rule 24 (stmt -> var_decl .)
    ID              reduce using rule 24 (stmt -> var_decl .)
    STR             reduce using rule 24 (stmt -> var_decl .)
    NUM_LIT         reduce using rule 24 (stmt -> var_decl .)
    NUM             reduce using rule 24 (stmt -> var_decl .)
    KW_SIZEOF       reduce using rule 24 (stmt -> var_decl .)
    KW_VOID         reduce using rule 24 (stmt -> var_decl .)
    KW_INT          reduce using rule 24 (stmt -> var_decl .)
    ;               reduce using rule 24 (stmt -> var_decl .)


state 36

    (25) stmt -> exp_stmt .
    }               reduce using rule 25 (stmt -> exp_stmt .)
    KW_FOR          reduce using rule 25 (stmt -> exp_stmt .)
    KW_CONTINUE     reduce using rule 25 (stmt -> exp_stmt .)
    KW_BREAK        reduce using rule 25 (stmt -> exp_stmt .)
    KW_WHILE        reduce using rule 25 (stmt -> exp_stmt .)
    {               reduce using rule 25 (stmt -> exp_stmt .)
    KW_IF           reduce using rule 25 (stmt -> exp_stmt .)
    KW_RETURN       reduce using rule 25 (stmt -> exp_stmt .)
    KW_STATIC       reduce using rule 25 (stmt -> exp_stmt .)
    (               reduce using rule 25 (stmt -> exp_stmt .)
    ~               reduce using rule 25 (stmt -> exp_stmt .)
    &               reduce using rule 25 (stmt -> exp_stmt .)
    *               reduce using rule 25 (stmt -> exp_stmt .)
    -               reduce using rule 25 (stmt -> exp_stmt .)
    !               reduce using rule 25 (stmt -> exp_stmt .)
    ID              reduce using rule 25 (stmt -> exp_stmt .)
    STR             reduce using rule 25 (stmt -> exp_stmt .)
    NUM_LIT         reduce using rule 25 (stmt -> exp_stmt .)
    NUM             reduce using rule 25 (stmt -> exp_stmt .)
    KW_SIZEOF       reduce using rule 25 (stmt -> exp_stmt .)
    KW_VOID         reduce using rule 25 (stmt -> exp_stmt .)
    KW_INT          reduce using rule 25 (stmt -> exp_stmt .)
    ;               reduce using rule 25 (stmt -> exp_stmt .)


state 37

    (29) for_stmt -> KW_FOR . ( for_decl for_cond for_exp ) block_stmt
    (               shift and go to state 78


state 38

    (93) unary -> ( . type_lit ) unary
    (112) atom -> ( . exp )
    (113) type_lit -> . type_lit_ptr
    (114) type_lit -> . type_lit [ NUM ]
    (63) exp -> . assign
    (115) type_lit_ptr -> . type
    (116) type_lit_ptr -> . type_lit_ptr *
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (117) type -> . KW_VOID
    (118) type -> . KW_INT
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    KW_VOID         shift and go to state 9
    KW_INT          shift and go to state 10
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    type_lit                       shift and go to state 79
    unary                          shift and go to state 49
    exp                            shift and go to state 80
    type_lit_ptr                   shift and go to state 81
    assign                         shift and go to state 47
    type                           shift and go to state 82
    or_exp                         shift and go to state 48
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 39

    (28) continue_stmt -> KW_CONTINUE . ;
    ;               shift and go to state 83


state 40

    (27) break_stmt -> KW_BREAK . ;
    ;               shift and go to state 84


state 41

    (26) while_stmt -> KW_WHILE . ( exp ) block_stmt
    (               shift and go to state 85


state 42

    (40) exp_stmt -> exp . ;
    ;               shift and go to state 86


state 43

    (36) if_stmt -> KW_IF . ( exp ) block_stmt else_stmt
    (               shift and go to state 87


state 44

    (41) return_stmt -> KW_RETURN . exp ;
    (42) return_stmt -> KW_RETURN . ;
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    ;               shift and go to state 89
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    exp                            shift and go to state 88
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 45

    (44) var_decl -> is_static . type var_decl_ ;
    (117) type -> . KW_VOID
    (118) type -> . KW_INT
    KW_VOID         shift and go to state 9
    KW_INT          shift and go to state 10

    type                           shift and go to state 90

state 46

    (46) is_static -> KW_STATIC .
    KW_VOID         reduce using rule 46 (is_static -> KW_STATIC .)
    KW_INT          reduce using rule 46 (is_static -> KW_STATIC .)


state 47

    (63) exp -> assign .
    ;               reduce using rule 63 (exp -> assign .)
    )               reduce using rule 63 (exp -> assign .)
    ,               reduce using rule 63 (exp -> assign .)
    ]               reduce using rule 63 (exp -> assign .)
    }               reduce using rule 63 (exp -> assign .)


state 48

    (64) assign -> or_exp .
    (67) or_exp -> or_exp . OR and_exp
    ;               reduce using rule 64 (assign -> or_exp .)
    )               reduce using rule 64 (assign -> or_exp .)
    ,               reduce using rule 64 (assign -> or_exp .)
    ]               reduce using rule 64 (assign -> or_exp .)
    }               reduce using rule 64 (assign -> or_exp .)
    OR              shift and go to state 91


state 49

    (65) assign -> unary . = assign
    (89) shiftop -> unary .
    =               shift and go to state 92
    SHIFT_L         reduce using rule 89 (shiftop -> unary .)
    SHIFT_R         reduce using rule 89 (shiftop -> unary .)
    /               reduce using rule 89 (shiftop -> unary .)
    *               reduce using rule 89 (shiftop -> unary .)
    <               reduce using rule 89 (shiftop -> unary .)
    >               reduce using rule 89 (shiftop -> unary .)
    GREATER_EQ      reduce using rule 89 (shiftop -> unary .)
    LESSER_EQ       reduce using rule 89 (shiftop -> unary .)
    NOT_EQ          reduce using rule 89 (shiftop -> unary .)
    EQ_EQ           reduce using rule 89 (shiftop -> unary .)
    -               reduce using rule 89 (shiftop -> unary .)
    +               reduce using rule 89 (shiftop -> unary .)
    &               reduce using rule 89 (shiftop -> unary .)
    ^               reduce using rule 89 (shiftop -> unary .)


state 50

    (66) or_exp -> and_exp .
    (69) and_exp -> and_exp . AND or_bin
    OR              reduce using rule 66 (or_exp -> and_exp .)
    ;               reduce using rule 66 (or_exp -> and_exp .)
    )               reduce using rule 66 (or_exp -> and_exp .)
    ,               reduce using rule 66 (or_exp -> and_exp .)
    ]               reduce using rule 66 (or_exp -> and_exp .)
    }               reduce using rule 66 (or_exp -> and_exp .)
    AND             shift and go to state 93


state 51

    (92) unary -> call .
    (100) call -> call . [ exp ]
    =               reduce using rule 92 (unary -> call .)
    SHIFT_L         reduce using rule 92 (unary -> call .)
    SHIFT_R         reduce using rule 92 (unary -> call .)
    /               reduce using rule 92 (unary -> call .)
    *               reduce using rule 92 (unary -> call .)
    <               reduce using rule 92 (unary -> call .)
    >               reduce using rule 92 (unary -> call .)
    GREATER_EQ      reduce using rule 92 (unary -> call .)
    LESSER_EQ       reduce using rule 92 (unary -> call .)
    NOT_EQ          reduce using rule 92 (unary -> call .)
    EQ_EQ           reduce using rule 92 (unary -> call .)
    -               reduce using rule 92 (unary -> call .)
    +               reduce using rule 92 (unary -> call .)
    &               reduce using rule 92 (unary -> call .)
    ^               reduce using rule 92 (unary -> call .)
    |               reduce using rule 92 (unary -> call .)
    AND             reduce using rule 92 (unary -> call .)
    OR              reduce using rule 92 (unary -> call .)
    ;               reduce using rule 92 (unary -> call .)
    )               reduce using rule 92 (unary -> call .)
    ,               reduce using rule 92 (unary -> call .)
    ]               reduce using rule 92 (unary -> call .)
    }               reduce using rule 92 (unary -> call .)
    [               shift and go to state 94


state 52

    (94) unary -> ~ . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 95
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 53

    (95) unary -> & . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 96
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 54

    (96) unary -> * . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 97
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 55

    (97) unary -> - . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 98
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 56

    (98) unary -> ! . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 99
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 57

    (68) and_exp -> or_bin .
    (71) or_bin -> or_bin . | xor_bin
    AND             reduce using rule 68 (and_exp -> or_bin .)
    OR              reduce using rule 68 (and_exp -> or_bin .)
    ;               reduce using rule 68 (and_exp -> or_bin .)
    )               reduce using rule 68 (and_exp -> or_bin .)
    ,               reduce using rule 68 (and_exp -> or_bin .)
    ]               reduce using rule 68 (and_exp -> or_bin .)
    }               reduce using rule 68 (and_exp -> or_bin .)
    |               shift and go to state 100


state 58

    (99) call -> atom .
    [               reduce using rule 99 (call -> atom .)
    =               reduce using rule 99 (call -> atom .)
    SHIFT_L         reduce using rule 99 (call -> atom .)
    SHIFT_R         reduce using rule 99 (call -> atom .)
    /               reduce using rule 99 (call -> atom .)
    *               reduce using rule 99 (call -> atom .)
    <               reduce using rule 99 (call -> atom .)
    >               reduce using rule 99 (call -> atom .)
    GREATER_EQ      reduce using rule 99 (call -> atom .)
    LESSER_EQ       reduce using rule 99 (call -> atom .)
    NOT_EQ          reduce using rule 99 (call -> atom .)
    EQ_EQ           reduce using rule 99 (call -> atom .)
    -               reduce using rule 99 (call -> atom .)
    +               reduce using rule 99 (call -> atom .)
    &               reduce using rule 99 (call -> atom .)
    ^               reduce using rule 99 (call -> atom .)
    |               reduce using rule 99 (call -> atom .)
    AND             reduce using rule 99 (call -> atom .)
    OR              reduce using rule 99 (call -> atom .)
    ;               reduce using rule 99 (call -> atom .)
    )               reduce using rule 99 (call -> atom .)
    ,               reduce using rule 99 (call -> atom .)
    ]               reduce using rule 99 (call -> atom .)
    }               reduce using rule 99 (call -> atom .)


state 59

    (101) call -> ID . ( call_args )
    (109) atom -> ID .
    (               shift and go to state 101
    [               reduce using rule 109 (atom -> ID .)
    =               reduce using rule 109 (atom -> ID .)
    SHIFT_L         reduce using rule 109 (atom -> ID .)
    SHIFT_R         reduce using rule 109 (atom -> ID .)
    /               reduce using rule 109 (atom -> ID .)
    *               reduce using rule 109 (atom -> ID .)
    <               reduce using rule 109 (atom -> ID .)
    >               reduce using rule 109 (atom -> ID .)
    GREATER_EQ      reduce using rule 109 (atom -> ID .)
    LESSER_EQ       reduce using rule 109 (atom -> ID .)
    NOT_EQ          reduce using rule 109 (atom -> ID .)
    EQ_EQ           reduce using rule 109 (atom -> ID .)
    -               reduce using rule 109 (atom -> ID .)
    +               reduce using rule 109 (atom -> ID .)
    &               reduce using rule 109 (atom -> ID .)
    ^               reduce using rule 109 (atom -> ID .)
    |               reduce using rule 109 (atom -> ID .)
    AND             reduce using rule 109 (atom -> ID .)
    OR              reduce using rule 109 (atom -> ID .)
    ;               reduce using rule 109 (atom -> ID .)
    )               reduce using rule 109 (atom -> ID .)
    ,               reduce using rule 109 (atom -> ID .)
    ]               reduce using rule 109 (atom -> ID .)
    }               reduce using rule 109 (atom -> ID .)


state 60

    (70) or_bin -> xor_bin . ^ and_bin
    (73) xor_bin -> xor_bin .
  ! shift/reduce conflict for ^ resolved as shift
    ^               shift and go to state 102


state 61

    (72) xor_bin -> and_bin .
    (75) and_bin -> and_bin . & comp_exp
    ^               reduce using rule 72 (xor_bin -> and_bin .)
    |               reduce using rule 72 (xor_bin -> and_bin .)
    AND             reduce using rule 72 (xor_bin -> and_bin .)
    OR              reduce using rule 72 (xor_bin -> and_bin .)
    ;               reduce using rule 72 (xor_bin -> and_bin .)
    )               reduce using rule 72 (xor_bin -> and_bin .)
    ,               reduce using rule 72 (xor_bin -> and_bin .)
    ]               reduce using rule 72 (xor_bin -> and_bin .)
    }               reduce using rule 72 (xor_bin -> and_bin .)
    &               shift and go to state 103


state 62

    (106) atom -> STR .
    [               reduce using rule 106 (atom -> STR .)
    =               reduce using rule 106 (atom -> STR .)
    SHIFT_L         reduce using rule 106 (atom -> STR .)
    SHIFT_R         reduce using rule 106 (atom -> STR .)
    /               reduce using rule 106 (atom -> STR .)
    *               reduce using rule 106 (atom -> STR .)
    <               reduce using rule 106 (atom -> STR .)
    >               reduce using rule 106 (atom -> STR .)
    GREATER_EQ      reduce using rule 106 (atom -> STR .)
    LESSER_EQ       reduce using rule 106 (atom -> STR .)
    NOT_EQ          reduce using rule 106 (atom -> STR .)
    EQ_EQ           reduce using rule 106 (atom -> STR .)
    -               reduce using rule 106 (atom -> STR .)
    +               reduce using rule 106 (atom -> STR .)
    &               reduce using rule 106 (atom -> STR .)
    ^               reduce using rule 106 (atom -> STR .)
    |               reduce using rule 106 (atom -> STR .)
    AND             reduce using rule 106 (atom -> STR .)
    OR              reduce using rule 106 (atom -> STR .)
    ;               reduce using rule 106 (atom -> STR .)
    )               reduce using rule 106 (atom -> STR .)
    ,               reduce using rule 106 (atom -> STR .)
    ]               reduce using rule 106 (atom -> STR .)
    }               reduce using rule 106 (atom -> STR .)


state 63

    (107) atom -> NUM_LIT .
    [               reduce using rule 107 (atom -> NUM_LIT .)
    =               reduce using rule 107 (atom -> NUM_LIT .)
    SHIFT_L         reduce using rule 107 (atom -> NUM_LIT .)
    SHIFT_R         reduce using rule 107 (atom -> NUM_LIT .)
    /               reduce using rule 107 (atom -> NUM_LIT .)
    *               reduce using rule 107 (atom -> NUM_LIT .)
    <               reduce using rule 107 (atom -> NUM_LIT .)
    >               reduce using rule 107 (atom -> NUM_LIT .)
    GREATER_EQ      reduce using rule 107 (atom -> NUM_LIT .)
    LESSER_EQ       reduce using rule 107 (atom -> NUM_LIT .)
    NOT_EQ          reduce using rule 107 (atom -> NUM_LIT .)
    EQ_EQ           reduce using rule 107 (atom -> NUM_LIT .)
    -               reduce using rule 107 (atom -> NUM_LIT .)
    +               reduce using rule 107 (atom -> NUM_LIT .)
    &               reduce using rule 107 (atom -> NUM_LIT .)
    ^               reduce using rule 107 (atom -> NUM_LIT .)
    |               reduce using rule 107 (atom -> NUM_LIT .)
    AND             reduce using rule 107 (atom -> NUM_LIT .)
    OR              reduce using rule 107 (atom -> NUM_LIT .)
    ;               reduce using rule 107 (atom -> NUM_LIT .)
    )               reduce using rule 107 (atom -> NUM_LIT .)
    ,               reduce using rule 107 (atom -> NUM_LIT .)
    ]               reduce using rule 107 (atom -> NUM_LIT .)
    }               reduce using rule 107 (atom -> NUM_LIT .)


state 64

    (108) atom -> NUM .
    [               reduce using rule 108 (atom -> NUM .)
    =               reduce using rule 108 (atom -> NUM .)
    SHIFT_L         reduce using rule 108 (atom -> NUM .)
    SHIFT_R         reduce using rule 108 (atom -> NUM .)
    /               reduce using rule 108 (atom -> NUM .)
    *               reduce using rule 108 (atom -> NUM .)
    <               reduce using rule 108 (atom -> NUM .)
    >               reduce using rule 108 (atom -> NUM .)
    GREATER_EQ      reduce using rule 108 (atom -> NUM .)
    LESSER_EQ       reduce using rule 108 (atom -> NUM .)
    NOT_EQ          reduce using rule 108 (atom -> NUM .)
    EQ_EQ           reduce using rule 108 (atom -> NUM .)
    -               reduce using rule 108 (atom -> NUM .)
    +               reduce using rule 108 (atom -> NUM .)
    &               reduce using rule 108 (atom -> NUM .)
    ^               reduce using rule 108 (atom -> NUM .)
    |               reduce using rule 108 (atom -> NUM .)
    AND             reduce using rule 108 (atom -> NUM .)
    OR              reduce using rule 108 (atom -> NUM .)
    ;               reduce using rule 108 (atom -> NUM .)
    )               reduce using rule 108 (atom -> NUM .)
    ,               reduce using rule 108 (atom -> NUM .)
    ]               reduce using rule 108 (atom -> NUM .)
    }               reduce using rule 108 (atom -> NUM .)


state 65

    (110) atom -> KW_SIZEOF . ( type_lit )
    (111) atom -> KW_SIZEOF . ( exp )
    (               shift and go to state 104


state 66

    (74) and_bin -> comp_exp .
    &               reduce using rule 74 (and_bin -> comp_exp .)
    ^               reduce using rule 74 (and_bin -> comp_exp .)
    |               reduce using rule 74 (and_bin -> comp_exp .)
    AND             reduce using rule 74 (and_bin -> comp_exp .)
    OR              reduce using rule 74 (and_bin -> comp_exp .)
    ;               reduce using rule 74 (and_bin -> comp_exp .)
    )               reduce using rule 74 (and_bin -> comp_exp .)
    ,               reduce using rule 74 (and_bin -> comp_exp .)
    ]               reduce using rule 74 (and_bin -> comp_exp .)
    }               reduce using rule 74 (and_bin -> comp_exp .)


state 67

    (76) comp_exp -> sum .
    (77) comp_exp -> sum . < comp_exp
    (78) comp_exp -> sum . > comp_exp
    (79) comp_exp -> sum . GREATER_EQ comp_exp
    (80) comp_exp -> sum . LESSER_EQ comp_exp
    (81) comp_exp -> sum . NOT_EQ comp_exp
    (82) comp_exp -> sum . EQ_EQ comp_exp
    (84) sum -> sum . - prod
    (85) sum -> sum . + prod
    &               reduce using rule 76 (comp_exp -> sum .)
    ^               reduce using rule 76 (comp_exp -> sum .)
    |               reduce using rule 76 (comp_exp -> sum .)
    AND             reduce using rule 76 (comp_exp -> sum .)
    OR              reduce using rule 76 (comp_exp -> sum .)
    ;               reduce using rule 76 (comp_exp -> sum .)
    )               reduce using rule 76 (comp_exp -> sum .)
    ,               reduce using rule 76 (comp_exp -> sum .)
    ]               reduce using rule 76 (comp_exp -> sum .)
    }               reduce using rule 76 (comp_exp -> sum .)
    <               shift and go to state 105
    >               shift and go to state 106
    GREATER_EQ      shift and go to state 107
    LESSER_EQ       shift and go to state 108
    NOT_EQ          shift and go to state 109
    EQ_EQ           shift and go to state 110
    -               shift and go to state 111
    +               shift and go to state 112


state 68

    (83) sum -> prod .
    (87) prod -> prod . / shiftop
    (88) prod -> prod . * shiftop
    <               reduce using rule 83 (sum -> prod .)
    >               reduce using rule 83 (sum -> prod .)
    GREATER_EQ      reduce using rule 83 (sum -> prod .)
    LESSER_EQ       reduce using rule 83 (sum -> prod .)
    NOT_EQ          reduce using rule 83 (sum -> prod .)
    EQ_EQ           reduce using rule 83 (sum -> prod .)
    -               reduce using rule 83 (sum -> prod .)
    +               reduce using rule 83 (sum -> prod .)
    &               reduce using rule 83 (sum -> prod .)
    ^               reduce using rule 83 (sum -> prod .)
    |               reduce using rule 83 (sum -> prod .)
    AND             reduce using rule 83 (sum -> prod .)
    OR              reduce using rule 83 (sum -> prod .)
    ;               reduce using rule 83 (sum -> prod .)
    )               reduce using rule 83 (sum -> prod .)
    ,               reduce using rule 83 (sum -> prod .)
    ]               reduce using rule 83 (sum -> prod .)
    }               reduce using rule 83 (sum -> prod .)
    /               shift and go to state 113
    *               shift and go to state 114


state 69

    (86) prod -> shiftop .
    (90) shiftop -> shiftop . SHIFT_L unary
    (91) shiftop -> shiftop . SHIFT_R unary
    /               reduce using rule 86 (prod -> shiftop .)
    *               reduce using rule 86 (prod -> shiftop .)
    <               reduce using rule 86 (prod -> shiftop .)
    >               reduce using rule 86 (prod -> shiftop .)
    GREATER_EQ      reduce using rule 86 (prod -> shiftop .)
    LESSER_EQ       reduce using rule 86 (prod -> shiftop .)
    NOT_EQ          reduce using rule 86 (prod -> shiftop .)
    EQ_EQ           reduce using rule 86 (prod -> shiftop .)
    -               reduce using rule 86 (prod -> shiftop .)
    +               reduce using rule 86 (prod -> shiftop .)
    &               reduce using rule 86 (prod -> shiftop .)
    ^               reduce using rule 86 (prod -> shiftop .)
    |               reduce using rule 86 (prod -> shiftop .)
    AND             reduce using rule 86 (prod -> shiftop .)
    OR              reduce using rule 86 (prod -> shiftop .)
    ;               reduce using rule 86 (prod -> shiftop .)
    )               reduce using rule 86 (prod -> shiftop .)
    ,               reduce using rule 86 (prod -> shiftop .)
    ]               reduce using rule 86 (prod -> shiftop .)
    }               reduce using rule 86 (prod -> shiftop .)
    SHIFT_L         shift and go to state 115
    SHIFT_R         shift and go to state 116


state 70

    (49) param_decl -> decl_ptrs ID . array_idxs var_decl_exp
    (55) array_idxs -> .
    (56) array_idxs -> . array_idxs [ NUM ]
    [               reduce using rule 55 (array_idxs -> .)
    =               reduce using rule 55 (array_idxs -> .)
    ;               reduce using rule 55 (array_idxs -> .)
    ,               reduce using rule 55 (array_idxs -> .)

    array_idxs                     shift and go to state 24

state 71

    (13) fun_args_ -> type . decl_ptrs ID
    (50) decl_ptrs -> .
    (51) decl_ptrs -> . decl_ptrs *
    ID              reduce using rule 50 (decl_ptrs -> .)
    *               reduce using rule 50 (decl_ptrs -> .)

    decl_ptrs                      shift and go to state 117

state 72

    (10) fun -> type decl_ptrs ID ( fun_args . )
    )               shift and go to state 118


state 73

    (12) fun_args -> fun_args_ .
    (14) fun_args_ -> fun_args_ . , type decl_ptrs ID
    )               reduce using rule 12 (fun_args -> fun_args_ .)
    ,               shift and go to state 119


state 74

    (49) param_decl -> decl_ptrs ID array_idxs var_decl_exp .
    ;               reduce using rule 49 (param_decl -> decl_ptrs ID array_idxs var_decl_exp .)
    ,               reduce using rule 49 (param_decl -> decl_ptrs ID array_idxs var_decl_exp .)


state 75

    (56) array_idxs -> array_idxs [ . NUM ]
    NUM             shift and go to state 120


state 76

    (52) var_decl_exp -> = . exp
    (53) var_decl_exp -> = . array
    (63) exp -> . assign
    (57) array -> . { array_base }
    (58) array -> . { array_rec }
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    {               shift and go to state 123
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    exp                            shift and go to state 121
    array                          shift and go to state 122
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 77

    (43) block_stmt -> { body . }
    (16) body -> body . stmt
    (17) stmt -> . for_stmt
    (18) stmt -> . continue_stmt
    (19) stmt -> . break_stmt
    (20) stmt -> . while_stmt
    (21) stmt -> . block_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . return_stmt
    (24) stmt -> . var_decl
    (25) stmt -> . exp_stmt
    (29) for_stmt -> . KW_FOR ( for_decl for_cond for_exp ) block_stmt
    (28) continue_stmt -> . KW_CONTINUE ;
    (27) break_stmt -> . KW_BREAK ;
    (26) while_stmt -> . KW_WHILE ( exp ) block_stmt
    (43) block_stmt -> . { body }
    (36) if_stmt -> . KW_IF ( exp ) block_stmt else_stmt
    (41) return_stmt -> . KW_RETURN exp ;
    (42) return_stmt -> . KW_RETURN ;
    (44) var_decl -> . is_static type var_decl_ ;
    (40) exp_stmt -> . exp ;
    (45) is_static -> .
    (46) is_static -> . KW_STATIC
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    }               shift and go to state 124
    KW_FOR          shift and go to state 37
    KW_CONTINUE     shift and go to state 39
    KW_BREAK        shift and go to state 40
    KW_WHILE        shift and go to state 41
    {               shift and go to state 25
    KW_IF           shift and go to state 43
    KW_RETURN       shift and go to state 44
    KW_VOID         reduce using rule 45 (is_static -> .)
    KW_INT          reduce using rule 45 (is_static -> .)
    KW_STATIC       shift and go to state 46
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    stmt                           shift and go to state 27
    for_stmt                       shift and go to state 28
    continue_stmt                  shift and go to state 29
    break_stmt                     shift and go to state 30
    while_stmt                     shift and go to state 31
    block_stmt                     shift and go to state 32
    if_stmt                        shift and go to state 33
    return_stmt                    shift and go to state 34
    var_decl                       shift and go to state 35
    exp_stmt                       shift and go to state 36
    exp                            shift and go to state 42
    is_static                      shift and go to state 45
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 78

    (29) for_stmt -> KW_FOR ( . for_decl for_cond for_exp ) block_stmt
    (30) for_decl -> . ;
    (31) for_decl -> . stmt
    (17) stmt -> . for_stmt
    (18) stmt -> . continue_stmt
    (19) stmt -> . break_stmt
    (20) stmt -> . while_stmt
    (21) stmt -> . block_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . return_stmt
    (24) stmt -> . var_decl
    (25) stmt -> . exp_stmt
    (29) for_stmt -> . KW_FOR ( for_decl for_cond for_exp ) block_stmt
    (28) continue_stmt -> . KW_CONTINUE ;
    (27) break_stmt -> . KW_BREAK ;
    (26) while_stmt -> . KW_WHILE ( exp ) block_stmt
    (43) block_stmt -> . { body }
    (36) if_stmt -> . KW_IF ( exp ) block_stmt else_stmt
    (41) return_stmt -> . KW_RETURN exp ;
    (42) return_stmt -> . KW_RETURN ;
    (44) var_decl -> . is_static type var_decl_ ;
    (40) exp_stmt -> . exp ;
    (45) is_static -> .
    (46) is_static -> . KW_STATIC
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    ;               shift and go to state 126
    KW_FOR          shift and go to state 37
    KW_CONTINUE     shift and go to state 39
    KW_BREAK        shift and go to state 40
    KW_WHILE        shift and go to state 41
    {               shift and go to state 25
    KW_IF           shift and go to state 43
    KW_RETURN       shift and go to state 44
    KW_VOID         reduce using rule 45 (is_static -> .)
    KW_INT          reduce using rule 45 (is_static -> .)
    KW_STATIC       shift and go to state 46
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    for_decl                       shift and go to state 125
    block_stmt                     shift and go to state 32
    stmt                           shift and go to state 127
    for_stmt                       shift and go to state 28
    continue_stmt                  shift and go to state 29
    break_stmt                     shift and go to state 30
    while_stmt                     shift and go to state 31
    if_stmt                        shift and go to state 33
    return_stmt                    shift and go to state 34
    var_decl                       shift and go to state 35
    exp_stmt                       shift and go to state 36
    exp                            shift and go to state 42
    is_static                      shift and go to state 45
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 79

    (93) unary -> ( type_lit . ) unary
    (114) type_lit -> type_lit . [ NUM ]
    )               shift and go to state 128
    [               shift and go to state 129


state 80

    (112) atom -> ( exp . )
    )               shift and go to state 130


state 81

    (113) type_lit -> type_lit_ptr .
    (116) type_lit_ptr -> type_lit_ptr . *
    )               reduce using rule 113 (type_lit -> type_lit_ptr .)
    [               reduce using rule 113 (type_lit -> type_lit_ptr .)
    *               shift and go to state 131


state 82

    (115) type_lit_ptr -> type .
    *               reduce using rule 115 (type_lit_ptr -> type .)
    )               reduce using rule 115 (type_lit_ptr -> type .)
    [               reduce using rule 115 (type_lit_ptr -> type .)


state 83

    (28) continue_stmt -> KW_CONTINUE ; .
    }               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_FOR          reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_CONTINUE     reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_BREAK        reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_WHILE        reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    {               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_IF           reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_RETURN       reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_STATIC       reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    (               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    ~               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    &               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    *               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    -               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    !               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    ID              reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    STR             reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    NUM_LIT         reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    NUM             reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_SIZEOF       reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_VOID         reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    KW_INT          reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)
    ;               reduce using rule 28 (continue_stmt -> KW_CONTINUE ; .)


state 84

    (27) break_stmt -> KW_BREAK ; .
    }               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_FOR          reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_CONTINUE     reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_BREAK        reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_WHILE        reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    {               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_IF           reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_RETURN       reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_STATIC       reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    (               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    ~               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    &               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    *               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    -               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    !               reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    ID              reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    STR             reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    NUM_LIT         reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    NUM             reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_SIZEOF       reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_VOID         reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    KW_INT          reduce using rule 27 (break_stmt -> KW_BREAK ; .)
    ;               reduce using rule 27 (break_stmt -> KW_BREAK ; .)


state 85

    (26) while_stmt -> KW_WHILE ( . exp ) block_stmt
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    exp                            shift and go to state 132
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 86

    (40) exp_stmt -> exp ; .
    }               reduce using rule 40 (exp_stmt -> exp ; .)
    KW_FOR          reduce using rule 40 (exp_stmt -> exp ; .)
    KW_CONTINUE     reduce using rule 40 (exp_stmt -> exp ; .)
    KW_BREAK        reduce using rule 40 (exp_stmt -> exp ; .)
    KW_WHILE        reduce using rule 40 (exp_stmt -> exp ; .)
    {               reduce using rule 40 (exp_stmt -> exp ; .)
    KW_IF           reduce using rule 40 (exp_stmt -> exp ; .)
    KW_RETURN       reduce using rule 40 (exp_stmt -> exp ; .)
    KW_STATIC       reduce using rule 40 (exp_stmt -> exp ; .)
    (               reduce using rule 40 (exp_stmt -> exp ; .)
    ~               reduce using rule 40 (exp_stmt -> exp ; .)
    &               reduce using rule 40 (exp_stmt -> exp ; .)
    *               reduce using rule 40 (exp_stmt -> exp ; .)
    -               reduce using rule 40 (exp_stmt -> exp ; .)
    !               reduce using rule 40 (exp_stmt -> exp ; .)
    ID              reduce using rule 40 (exp_stmt -> exp ; .)
    STR             reduce using rule 40 (exp_stmt -> exp ; .)
    NUM_LIT         reduce using rule 40 (exp_stmt -> exp ; .)
    NUM             reduce using rule 40 (exp_stmt -> exp ; .)
    KW_SIZEOF       reduce using rule 40 (exp_stmt -> exp ; .)
    KW_VOID         reduce using rule 40 (exp_stmt -> exp ; .)
    KW_INT          reduce using rule 40 (exp_stmt -> exp ; .)
    ;               reduce using rule 40 (exp_stmt -> exp ; .)


state 87

    (36) if_stmt -> KW_IF ( . exp ) block_stmt else_stmt
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    exp                            shift and go to state 133
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 88

    (41) return_stmt -> KW_RETURN exp . ;
    ;               shift and go to state 134


state 89

    (42) return_stmt -> KW_RETURN ; .
    }               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_FOR          reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_CONTINUE     reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_BREAK        reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_WHILE        reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    {               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_IF           reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_RETURN       reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_STATIC       reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    (               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    ~               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    &               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    *               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    -               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    !               reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    ID              reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    STR             reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    NUM_LIT         reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    NUM             reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_SIZEOF       reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_VOID         reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    KW_INT          reduce using rule 42 (return_stmt -> KW_RETURN ; .)
    ;               reduce using rule 42 (return_stmt -> KW_RETURN ; .)


state 90

    (44) var_decl -> is_static type . var_decl_ ;
    (47) var_decl_ -> . param_decl
    (48) var_decl_ -> . var_decl_ , param_decl
    (49) param_decl -> . decl_ptrs ID array_idxs var_decl_exp
    (50) decl_ptrs -> .
    (51) decl_ptrs -> . decl_ptrs *
    ID              reduce using rule 50 (decl_ptrs -> .)
    *               reduce using rule 50 (decl_ptrs -> .)

    var_decl_                      shift and go to state 135
    param_decl                     shift and go to state 13
    decl_ptrs                      shift and go to state 22

state 91

    (67) or_exp -> or_exp OR . and_exp
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    and_exp                        shift and go to state 136
    or_bin                         shift and go to state 57
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 92

    (65) assign -> unary = . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 49
    assign                         shift and go to state 138
    or_exp                         shift and go to state 48
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 93

    (69) and_exp -> and_exp AND . or_bin
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    or_bin                         shift and go to state 139
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 94

    (100) call -> call [ . exp ]
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    call                           shift and go to state 51
    exp                            shift and go to state 140
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 95

    (94) unary -> ~ unary .
    =               reduce using rule 94 (unary -> ~ unary .)
    SHIFT_L         reduce using rule 94 (unary -> ~ unary .)
    SHIFT_R         reduce using rule 94 (unary -> ~ unary .)
    /               reduce using rule 94 (unary -> ~ unary .)
    *               reduce using rule 94 (unary -> ~ unary .)
    <               reduce using rule 94 (unary -> ~ unary .)
    >               reduce using rule 94 (unary -> ~ unary .)
    GREATER_EQ      reduce using rule 94 (unary -> ~ unary .)
    LESSER_EQ       reduce using rule 94 (unary -> ~ unary .)
    NOT_EQ          reduce using rule 94 (unary -> ~ unary .)
    EQ_EQ           reduce using rule 94 (unary -> ~ unary .)
    -               reduce using rule 94 (unary -> ~ unary .)
    +               reduce using rule 94 (unary -> ~ unary .)
    &               reduce using rule 94 (unary -> ~ unary .)
    ^               reduce using rule 94 (unary -> ~ unary .)
    |               reduce using rule 94 (unary -> ~ unary .)
    AND             reduce using rule 94 (unary -> ~ unary .)
    OR              reduce using rule 94 (unary -> ~ unary .)
    ;               reduce using rule 94 (unary -> ~ unary .)
    )               reduce using rule 94 (unary -> ~ unary .)
    ,               reduce using rule 94 (unary -> ~ unary .)
    ]               reduce using rule 94 (unary -> ~ unary .)
    }               reduce using rule 94 (unary -> ~ unary .)


state 96

    (95) unary -> & unary .
    =               reduce using rule 95 (unary -> & unary .)
    SHIFT_L         reduce using rule 95 (unary -> & unary .)
    SHIFT_R         reduce using rule 95 (unary -> & unary .)
    /               reduce using rule 95 (unary -> & unary .)
    *               reduce using rule 95 (unary -> & unary .)
    <               reduce using rule 95 (unary -> & unary .)
    >               reduce using rule 95 (unary -> & unary .)
    GREATER_EQ      reduce using rule 95 (unary -> & unary .)
    LESSER_EQ       reduce using rule 95 (unary -> & unary .)
    NOT_EQ          reduce using rule 95 (unary -> & unary .)
    EQ_EQ           reduce using rule 95 (unary -> & unary .)
    -               reduce using rule 95 (unary -> & unary .)
    +               reduce using rule 95 (unary -> & unary .)
    &               reduce using rule 95 (unary -> & unary .)
    ^               reduce using rule 95 (unary -> & unary .)
    |               reduce using rule 95 (unary -> & unary .)
    AND             reduce using rule 95 (unary -> & unary .)
    OR              reduce using rule 95 (unary -> & unary .)
    ;               reduce using rule 95 (unary -> & unary .)
    )               reduce using rule 95 (unary -> & unary .)
    ,               reduce using rule 95 (unary -> & unary .)
    ]               reduce using rule 95 (unary -> & unary .)
    }               reduce using rule 95 (unary -> & unary .)


state 97

    (96) unary -> * unary .
    =               reduce using rule 96 (unary -> * unary .)
    SHIFT_L         reduce using rule 96 (unary -> * unary .)
    SHIFT_R         reduce using rule 96 (unary -> * unary .)
    /               reduce using rule 96 (unary -> * unary .)
    *               reduce using rule 96 (unary -> * unary .)
    <               reduce using rule 96 (unary -> * unary .)
    >               reduce using rule 96 (unary -> * unary .)
    GREATER_EQ      reduce using rule 96 (unary -> * unary .)
    LESSER_EQ       reduce using rule 96 (unary -> * unary .)
    NOT_EQ          reduce using rule 96 (unary -> * unary .)
    EQ_EQ           reduce using rule 96 (unary -> * unary .)
    -               reduce using rule 96 (unary -> * unary .)
    +               reduce using rule 96 (unary -> * unary .)
    &               reduce using rule 96 (unary -> * unary .)
    ^               reduce using rule 96 (unary -> * unary .)
    |               reduce using rule 96 (unary -> * unary .)
    AND             reduce using rule 96 (unary -> * unary .)
    OR              reduce using rule 96 (unary -> * unary .)
    ;               reduce using rule 96 (unary -> * unary .)
    )               reduce using rule 96 (unary -> * unary .)
    ,               reduce using rule 96 (unary -> * unary .)
    ]               reduce using rule 96 (unary -> * unary .)
    }               reduce using rule 96 (unary -> * unary .)


state 98

    (97) unary -> - unary .
    =               reduce using rule 97 (unary -> - unary .)
    SHIFT_L         reduce using rule 97 (unary -> - unary .)
    SHIFT_R         reduce using rule 97 (unary -> - unary .)
    /               reduce using rule 97 (unary -> - unary .)
    *               reduce using rule 97 (unary -> - unary .)
    <               reduce using rule 97 (unary -> - unary .)
    >               reduce using rule 97 (unary -> - unary .)
    GREATER_EQ      reduce using rule 97 (unary -> - unary .)
    LESSER_EQ       reduce using rule 97 (unary -> - unary .)
    NOT_EQ          reduce using rule 97 (unary -> - unary .)
    EQ_EQ           reduce using rule 97 (unary -> - unary .)
    -               reduce using rule 97 (unary -> - unary .)
    +               reduce using rule 97 (unary -> - unary .)
    &               reduce using rule 97 (unary -> - unary .)
    ^               reduce using rule 97 (unary -> - unary .)
    |               reduce using rule 97 (unary -> - unary .)
    AND             reduce using rule 97 (unary -> - unary .)
    OR              reduce using rule 97 (unary -> - unary .)
    ;               reduce using rule 97 (unary -> - unary .)
    )               reduce using rule 97 (unary -> - unary .)
    ,               reduce using rule 97 (unary -> - unary .)
    ]               reduce using rule 97 (unary -> - unary .)
    }               reduce using rule 97 (unary -> - unary .)


state 99

    (98) unary -> ! unary .
    =               reduce using rule 98 (unary -> ! unary .)
    SHIFT_L         reduce using rule 98 (unary -> ! unary .)
    SHIFT_R         reduce using rule 98 (unary -> ! unary .)
    /               reduce using rule 98 (unary -> ! unary .)
    *               reduce using rule 98 (unary -> ! unary .)
    <               reduce using rule 98 (unary -> ! unary .)
    >               reduce using rule 98 (unary -> ! unary .)
    GREATER_EQ      reduce using rule 98 (unary -> ! unary .)
    LESSER_EQ       reduce using rule 98 (unary -> ! unary .)
    NOT_EQ          reduce using rule 98 (unary -> ! unary .)
    EQ_EQ           reduce using rule 98 (unary -> ! unary .)
    -               reduce using rule 98 (unary -> ! unary .)
    +               reduce using rule 98 (unary -> ! unary .)
    &               reduce using rule 98 (unary -> ! unary .)
    ^               reduce using rule 98 (unary -> ! unary .)
    |               reduce using rule 98 (unary -> ! unary .)
    AND             reduce using rule 98 (unary -> ! unary .)
    OR              reduce using rule 98 (unary -> ! unary .)
    ;               reduce using rule 98 (unary -> ! unary .)
    )               reduce using rule 98 (unary -> ! unary .)
    ,               reduce using rule 98 (unary -> ! unary .)
    ]               reduce using rule 98 (unary -> ! unary .)
    }               reduce using rule 98 (unary -> ! unary .)


state 100

    (71) or_bin -> or_bin | . xor_bin
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    xor_bin                        shift and go to state 141
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 101

    (101) call -> ID ( . call_args )
    (102) call_args -> . call_args_
    (103) call_args -> .
    (104) call_args_ -> . exp
    (105) call_args_ -> . call_args_ , exp
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    )               reduce using rule 103 (call_args -> .)
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    call_args                      shift and go to state 142
    call_args_                     shift and go to state 143
    exp                            shift and go to state 144
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 102

    (70) or_bin -> xor_bin ^ . and_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    and_bin                        shift and go to state 145
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 103

    (75) and_bin -> and_bin & . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    comp_exp                       shift and go to state 146
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 104

    (110) atom -> KW_SIZEOF ( . type_lit )
    (111) atom -> KW_SIZEOF ( . exp )
    (113) type_lit -> . type_lit_ptr
    (114) type_lit -> . type_lit [ NUM ]
    (63) exp -> . assign
    (115) type_lit_ptr -> . type
    (116) type_lit_ptr -> . type_lit_ptr *
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (117) type -> . KW_VOID
    (118) type -> . KW_INT
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    KW_VOID         shift and go to state 9
    KW_INT          shift and go to state 10
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    type_lit                       shift and go to state 147
    exp                            shift and go to state 148
    type_lit_ptr                   shift and go to state 81
    assign                         shift and go to state 47
    type                           shift and go to state 82
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 105

    (77) comp_exp -> sum < . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    sum                            shift and go to state 67
    comp_exp                       shift and go to state 149
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 106

    (78) comp_exp -> sum > . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    sum                            shift and go to state 67
    comp_exp                       shift and go to state 150
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 107

    (79) comp_exp -> sum GREATER_EQ . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    sum                            shift and go to state 67
    comp_exp                       shift and go to state 151
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 108

    (80) comp_exp -> sum LESSER_EQ . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    sum                            shift and go to state 67
    comp_exp                       shift and go to state 152
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 109

    (81) comp_exp -> sum NOT_EQ . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    sum                            shift and go to state 67
    comp_exp                       shift and go to state 153
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 110

    (82) comp_exp -> sum EQ_EQ . comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    sum                            shift and go to state 67
    comp_exp                       shift and go to state 154
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 111

    (84) sum -> sum - . prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    prod                           shift and go to state 155
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 112

    (85) sum -> sum + . prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    prod                           shift and go to state 156
    shiftop                        shift and go to state 69
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 113

    (87) prod -> prod / . shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    shiftop                        shift and go to state 157
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 114

    (88) prod -> prod * . shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    shiftop                        shift and go to state 158
    unary                          shift and go to state 137
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 115

    (90) shiftop -> shiftop SHIFT_L . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 159
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 116

    (91) shiftop -> shiftop SHIFT_R . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 160
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 117

    (13) fun_args_ -> type decl_ptrs . ID
    (51) decl_ptrs -> decl_ptrs . *
    ID              shift and go to state 161
    *               shift and go to state 19


state 118

    (10) fun -> type decl_ptrs ID ( fun_args ) .
    {               reduce using rule 10 (fun -> type decl_ptrs ID ( fun_args ) .)
    ;               reduce using rule 10 (fun -> type decl_ptrs ID ( fun_args ) .)


state 119

    (14) fun_args_ -> fun_args_ , . type decl_ptrs ID
    (117) type -> . KW_VOID
    (118) type -> . KW_INT
    KW_VOID         shift and go to state 9
    KW_INT          shift and go to state 10

    type                           shift and go to state 162

state 120

    (56) array_idxs -> array_idxs [ NUM . ]
    ]               shift and go to state 163


state 121

    (52) var_decl_exp -> = exp .
    ;               reduce using rule 52 (var_decl_exp -> = exp .)
    ,               reduce using rule 52 (var_decl_exp -> = exp .)


state 122

    (53) var_decl_exp -> = array .
    ;               reduce using rule 53 (var_decl_exp -> = array .)
    ,               reduce using rule 53 (var_decl_exp -> = array .)


state 123

    (57) array -> { . array_base }
    (58) array -> { . array_rec }
    (61) array_base -> . exp
    (62) array_base -> . array_base , exp
    (59) array_rec -> . array
    (60) array_rec -> . array_rec , array
    (63) exp -> . assign
    (57) array -> . { array_base }
    (58) array -> . { array_rec }
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    {               shift and go to state 123
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    array_base                     shift and go to state 164
    array_rec                      shift and go to state 165
    exp                            shift and go to state 166
    array                          shift and go to state 167
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 124

    (43) block_stmt -> { body } .
    }               reduce using rule 43 (block_stmt -> { body } .)
    KW_FOR          reduce using rule 43 (block_stmt -> { body } .)
    KW_CONTINUE     reduce using rule 43 (block_stmt -> { body } .)
    KW_BREAK        reduce using rule 43 (block_stmt -> { body } .)
    KW_WHILE        reduce using rule 43 (block_stmt -> { body } .)
    {               reduce using rule 43 (block_stmt -> { body } .)
    KW_IF           reduce using rule 43 (block_stmt -> { body } .)
    KW_RETURN       reduce using rule 43 (block_stmt -> { body } .)
    KW_STATIC       reduce using rule 43 (block_stmt -> { body } .)
    (               reduce using rule 43 (block_stmt -> { body } .)
    ~               reduce using rule 43 (block_stmt -> { body } .)
    &               reduce using rule 43 (block_stmt -> { body } .)
    *               reduce using rule 43 (block_stmt -> { body } .)
    -               reduce using rule 43 (block_stmt -> { body } .)
    !               reduce using rule 43 (block_stmt -> { body } .)
    ID              reduce using rule 43 (block_stmt -> { body } .)
    STR             reduce using rule 43 (block_stmt -> { body } .)
    NUM_LIT         reduce using rule 43 (block_stmt -> { body } .)
    NUM             reduce using rule 43 (block_stmt -> { body } .)
    KW_SIZEOF       reduce using rule 43 (block_stmt -> { body } .)
    KW_VOID         reduce using rule 43 (block_stmt -> { body } .)
    KW_INT          reduce using rule 43 (block_stmt -> { body } .)
    ;               reduce using rule 43 (block_stmt -> { body } .)
    KW_ELSE         reduce using rule 43 (block_stmt -> { body } .)


state 125

    (29) for_stmt -> KW_FOR ( for_decl . for_cond for_exp ) block_stmt
    (32) for_cond -> . ;
    (33) for_cond -> . exp ;
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    ;               shift and go to state 169
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    for_cond                       shift and go to state 168
    exp                            shift and go to state 170
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 126

    (30) for_decl -> ; .
    ;               reduce using rule 30 (for_decl -> ; .)
    (               reduce using rule 30 (for_decl -> ; .)
    ~               reduce using rule 30 (for_decl -> ; .)
    &               reduce using rule 30 (for_decl -> ; .)
    *               reduce using rule 30 (for_decl -> ; .)
    -               reduce using rule 30 (for_decl -> ; .)
    !               reduce using rule 30 (for_decl -> ; .)
    ID              reduce using rule 30 (for_decl -> ; .)
    STR             reduce using rule 30 (for_decl -> ; .)
    NUM_LIT         reduce using rule 30 (for_decl -> ; .)
    NUM             reduce using rule 30 (for_decl -> ; .)
    KW_SIZEOF       reduce using rule 30 (for_decl -> ; .)


state 127

    (31) for_decl -> stmt .
    ;               reduce using rule 31 (for_decl -> stmt .)
    (               reduce using rule 31 (for_decl -> stmt .)
    ~               reduce using rule 31 (for_decl -> stmt .)
    &               reduce using rule 31 (for_decl -> stmt .)
    *               reduce using rule 31 (for_decl -> stmt .)
    -               reduce using rule 31 (for_decl -> stmt .)
    !               reduce using rule 31 (for_decl -> stmt .)
    ID              reduce using rule 31 (for_decl -> stmt .)
    STR             reduce using rule 31 (for_decl -> stmt .)
    NUM_LIT         reduce using rule 31 (for_decl -> stmt .)
    NUM             reduce using rule 31 (for_decl -> stmt .)
    KW_SIZEOF       reduce using rule 31 (for_decl -> stmt .)


state 128

    (93) unary -> ( type_lit ) . unary
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    unary                          shift and go to state 171
    call                           shift and go to state 51
    atom                           shift and go to state 58

state 129

    (114) type_lit -> type_lit [ . NUM ]
    NUM             shift and go to state 172


state 130

    (112) atom -> ( exp ) .
    [               reduce using rule 112 (atom -> ( exp ) .)
    =               reduce using rule 112 (atom -> ( exp ) .)
    SHIFT_L         reduce using rule 112 (atom -> ( exp ) .)
    SHIFT_R         reduce using rule 112 (atom -> ( exp ) .)
    /               reduce using rule 112 (atom -> ( exp ) .)
    *               reduce using rule 112 (atom -> ( exp ) .)
    <               reduce using rule 112 (atom -> ( exp ) .)
    >               reduce using rule 112 (atom -> ( exp ) .)
    GREATER_EQ      reduce using rule 112 (atom -> ( exp ) .)
    LESSER_EQ       reduce using rule 112 (atom -> ( exp ) .)
    NOT_EQ          reduce using rule 112 (atom -> ( exp ) .)
    EQ_EQ           reduce using rule 112 (atom -> ( exp ) .)
    -               reduce using rule 112 (atom -> ( exp ) .)
    +               reduce using rule 112 (atom -> ( exp ) .)
    &               reduce using rule 112 (atom -> ( exp ) .)
    ^               reduce using rule 112 (atom -> ( exp ) .)
    |               reduce using rule 112 (atom -> ( exp ) .)
    AND             reduce using rule 112 (atom -> ( exp ) .)
    OR              reduce using rule 112 (atom -> ( exp ) .)
    ;               reduce using rule 112 (atom -> ( exp ) .)
    )               reduce using rule 112 (atom -> ( exp ) .)
    ,               reduce using rule 112 (atom -> ( exp ) .)
    ]               reduce using rule 112 (atom -> ( exp ) .)
    }               reduce using rule 112 (atom -> ( exp ) .)


state 131

    (116) type_lit_ptr -> type_lit_ptr * .
    *               reduce using rule 116 (type_lit_ptr -> type_lit_ptr * .)
    )               reduce using rule 116 (type_lit_ptr -> type_lit_ptr * .)
    [               reduce using rule 116 (type_lit_ptr -> type_lit_ptr * .)


state 132

    (26) while_stmt -> KW_WHILE ( exp . ) block_stmt
    )               shift and go to state 173


state 133

    (36) if_stmt -> KW_IF ( exp . ) block_stmt else_stmt
    )               shift and go to state 174


state 134

    (41) return_stmt -> KW_RETURN exp ; .
    }               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_FOR          reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_CONTINUE     reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_BREAK        reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_WHILE        reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    {               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_IF           reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_RETURN       reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_STATIC       reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    (               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    ~               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    &               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    *               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    -               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    !               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    ID              reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    STR             reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    NUM_LIT         reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    NUM             reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_SIZEOF       reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_VOID         reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    KW_INT          reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)
    ;               reduce using rule 41 (return_stmt -> KW_RETURN exp ; .)


state 135

    (44) var_decl -> is_static type var_decl_ . ;
    (48) var_decl_ -> var_decl_ . , param_decl
    ;               shift and go to state 175
    ,               shift and go to state 17


state 136

    (67) or_exp -> or_exp OR and_exp .
    (69) and_exp -> and_exp . AND or_bin
    OR              reduce using rule 67 (or_exp -> or_exp OR and_exp .)
    ;               reduce using rule 67 (or_exp -> or_exp OR and_exp .)
    )               reduce using rule 67 (or_exp -> or_exp OR and_exp .)
    ,               reduce using rule 67 (or_exp -> or_exp OR and_exp .)
    ]               reduce using rule 67 (or_exp -> or_exp OR and_exp .)
    }               reduce using rule 67 (or_exp -> or_exp OR and_exp .)
    AND             shift and go to state 93


state 137

    (89) shiftop -> unary .
    SHIFT_L         reduce using rule 89 (shiftop -> unary .)
    SHIFT_R         reduce using rule 89 (shiftop -> unary .)
    /               reduce using rule 89 (shiftop -> unary .)
    *               reduce using rule 89 (shiftop -> unary .)
    <               reduce using rule 89 (shiftop -> unary .)
    >               reduce using rule 89 (shiftop -> unary .)
    GREATER_EQ      reduce using rule 89 (shiftop -> unary .)
    LESSER_EQ       reduce using rule 89 (shiftop -> unary .)
    NOT_EQ          reduce using rule 89 (shiftop -> unary .)
    EQ_EQ           reduce using rule 89 (shiftop -> unary .)
    -               reduce using rule 89 (shiftop -> unary .)
    +               reduce using rule 89 (shiftop -> unary .)
    &               reduce using rule 89 (shiftop -> unary .)
    ^               reduce using rule 89 (shiftop -> unary .)
    |               reduce using rule 89 (shiftop -> unary .)
    AND             reduce using rule 89 (shiftop -> unary .)
    OR              reduce using rule 89 (shiftop -> unary .)
    ;               reduce using rule 89 (shiftop -> unary .)
    )               reduce using rule 89 (shiftop -> unary .)
    ,               reduce using rule 89 (shiftop -> unary .)
    ]               reduce using rule 89 (shiftop -> unary .)
    }               reduce using rule 89 (shiftop -> unary .)


state 138

    (65) assign -> unary = assign .
    ;               reduce using rule 65 (assign -> unary = assign .)
    )               reduce using rule 65 (assign -> unary = assign .)
    ,               reduce using rule 65 (assign -> unary = assign .)
    ]               reduce using rule 65 (assign -> unary = assign .)
    }               reduce using rule 65 (assign -> unary = assign .)


state 139

    (69) and_exp -> and_exp AND or_bin .
    (71) or_bin -> or_bin . | xor_bin
    AND             reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    OR              reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    ;               reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    )               reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    ,               reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    ]               reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    }               reduce using rule 69 (and_exp -> and_exp AND or_bin .)
    |               shift and go to state 100


state 140

    (100) call -> call [ exp . ]
    ]               shift and go to state 176


state 141

    (71) or_bin -> or_bin | xor_bin .
    (73) xor_bin -> xor_bin .
  ! reduce/reduce conflict for | resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for AND resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for OR resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for ; resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for ) resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for , resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for ] resolved using rule 71 (or_bin -> or_bin | xor_bin .)
  ! reduce/reduce conflict for } resolved using rule 71 (or_bin -> or_bin | xor_bin .)
    |               reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    AND             reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    OR              reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    ;               reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    )               reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    ,               reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    ]               reduce using rule 71 (or_bin -> or_bin | xor_bin .)
    }               reduce using rule 71 (or_bin -> or_bin | xor_bin .)


state 142

    (101) call -> ID ( call_args . )
    )               shift and go to state 177


state 143

    (102) call_args -> call_args_ .
    (105) call_args_ -> call_args_ . , exp
    )               reduce using rule 102 (call_args -> call_args_ .)
    ,               shift and go to state 178


state 144

    (104) call_args_ -> exp .
    ,               reduce using rule 104 (call_args_ -> exp .)
    )               reduce using rule 104 (call_args_ -> exp .)


state 145

    (70) or_bin -> xor_bin ^ and_bin .
    (75) and_bin -> and_bin . & comp_exp
    |               reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    AND             reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    OR              reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    ;               reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    )               reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    ,               reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    ]               reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    }               reduce using rule 70 (or_bin -> xor_bin ^ and_bin .)
    &               shift and go to state 103


state 146

    (75) and_bin -> and_bin & comp_exp .
    &               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    ^               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    |               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    AND             reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    OR              reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    ;               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    )               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    ,               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    ]               reduce using rule 75 (and_bin -> and_bin & comp_exp .)
    }               reduce using rule 75 (and_bin -> and_bin & comp_exp .)


state 147

    (110) atom -> KW_SIZEOF ( type_lit . )
    (114) type_lit -> type_lit . [ NUM ]
    )               shift and go to state 179
    [               shift and go to state 129


state 148

    (111) atom -> KW_SIZEOF ( exp . )
    )               shift and go to state 180


state 149

    (77) comp_exp -> sum < comp_exp .
    &               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    ^               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    |               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    AND             reduce using rule 77 (comp_exp -> sum < comp_exp .)
    OR              reduce using rule 77 (comp_exp -> sum < comp_exp .)
    ;               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    )               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    ,               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    ]               reduce using rule 77 (comp_exp -> sum < comp_exp .)
    }               reduce using rule 77 (comp_exp -> sum < comp_exp .)


state 150

    (78) comp_exp -> sum > comp_exp .
    &               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    ^               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    |               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    AND             reduce using rule 78 (comp_exp -> sum > comp_exp .)
    OR              reduce using rule 78 (comp_exp -> sum > comp_exp .)
    ;               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    )               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    ,               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    ]               reduce using rule 78 (comp_exp -> sum > comp_exp .)
    }               reduce using rule 78 (comp_exp -> sum > comp_exp .)


state 151

    (79) comp_exp -> sum GREATER_EQ comp_exp .
    &               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    ^               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    |               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    AND             reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    OR              reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    ;               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    )               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    ,               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    ]               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)
    }               reduce using rule 79 (comp_exp -> sum GREATER_EQ comp_exp .)


state 152

    (80) comp_exp -> sum LESSER_EQ comp_exp .
    &               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    ^               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    |               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    AND             reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    OR              reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    ;               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    )               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    ,               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    ]               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)
    }               reduce using rule 80 (comp_exp -> sum LESSER_EQ comp_exp .)


state 153

    (81) comp_exp -> sum NOT_EQ comp_exp .
    &               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    ^               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    |               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    AND             reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    OR              reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    ;               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    )               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    ,               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    ]               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)
    }               reduce using rule 81 (comp_exp -> sum NOT_EQ comp_exp .)


state 154

    (82) comp_exp -> sum EQ_EQ comp_exp .
    &               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    ^               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    |               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    AND             reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    OR              reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    ;               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    )               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    ,               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    ]               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)
    }               reduce using rule 82 (comp_exp -> sum EQ_EQ comp_exp .)


state 155

    (84) sum -> sum - prod .
    (87) prod -> prod . / shiftop
    (88) prod -> prod . * shiftop
    <               reduce using rule 84 (sum -> sum - prod .)
    >               reduce using rule 84 (sum -> sum - prod .)
    GREATER_EQ      reduce using rule 84 (sum -> sum - prod .)
    LESSER_EQ       reduce using rule 84 (sum -> sum - prod .)
    NOT_EQ          reduce using rule 84 (sum -> sum - prod .)
    EQ_EQ           reduce using rule 84 (sum -> sum - prod .)
    -               reduce using rule 84 (sum -> sum - prod .)
    +               reduce using rule 84 (sum -> sum - prod .)
    &               reduce using rule 84 (sum -> sum - prod .)
    ^               reduce using rule 84 (sum -> sum - prod .)
    |               reduce using rule 84 (sum -> sum - prod .)
    AND             reduce using rule 84 (sum -> sum - prod .)
    OR              reduce using rule 84 (sum -> sum - prod .)
    ;               reduce using rule 84 (sum -> sum - prod .)
    )               reduce using rule 84 (sum -> sum - prod .)
    ,               reduce using rule 84 (sum -> sum - prod .)
    ]               reduce using rule 84 (sum -> sum - prod .)
    }               reduce using rule 84 (sum -> sum - prod .)
    /               shift and go to state 113
    *               shift and go to state 114


state 156

    (85) sum -> sum + prod .
    (87) prod -> prod . / shiftop
    (88) prod -> prod . * shiftop
    <               reduce using rule 85 (sum -> sum + prod .)
    >               reduce using rule 85 (sum -> sum + prod .)
    GREATER_EQ      reduce using rule 85 (sum -> sum + prod .)
    LESSER_EQ       reduce using rule 85 (sum -> sum + prod .)
    NOT_EQ          reduce using rule 85 (sum -> sum + prod .)
    EQ_EQ           reduce using rule 85 (sum -> sum + prod .)
    -               reduce using rule 85 (sum -> sum + prod .)
    +               reduce using rule 85 (sum -> sum + prod .)
    &               reduce using rule 85 (sum -> sum + prod .)
    ^               reduce using rule 85 (sum -> sum + prod .)
    |               reduce using rule 85 (sum -> sum + prod .)
    AND             reduce using rule 85 (sum -> sum + prod .)
    OR              reduce using rule 85 (sum -> sum + prod .)
    ;               reduce using rule 85 (sum -> sum + prod .)
    )               reduce using rule 85 (sum -> sum + prod .)
    ,               reduce using rule 85 (sum -> sum + prod .)
    ]               reduce using rule 85 (sum -> sum + prod .)
    }               reduce using rule 85 (sum -> sum + prod .)
    /               shift and go to state 113
    *               shift and go to state 114


state 157

    (87) prod -> prod / shiftop .
    (90) shiftop -> shiftop . SHIFT_L unary
    (91) shiftop -> shiftop . SHIFT_R unary
    /               reduce using rule 87 (prod -> prod / shiftop .)
    *               reduce using rule 87 (prod -> prod / shiftop .)
    <               reduce using rule 87 (prod -> prod / shiftop .)
    >               reduce using rule 87 (prod -> prod / shiftop .)
    GREATER_EQ      reduce using rule 87 (prod -> prod / shiftop .)
    LESSER_EQ       reduce using rule 87 (prod -> prod / shiftop .)
    NOT_EQ          reduce using rule 87 (prod -> prod / shiftop .)
    EQ_EQ           reduce using rule 87 (prod -> prod / shiftop .)
    -               reduce using rule 87 (prod -> prod / shiftop .)
    +               reduce using rule 87 (prod -> prod / shiftop .)
    &               reduce using rule 87 (prod -> prod / shiftop .)
    ^               reduce using rule 87 (prod -> prod / shiftop .)
    |               reduce using rule 87 (prod -> prod / shiftop .)
    AND             reduce using rule 87 (prod -> prod / shiftop .)
    OR              reduce using rule 87 (prod -> prod / shiftop .)
    ;               reduce using rule 87 (prod -> prod / shiftop .)
    )               reduce using rule 87 (prod -> prod / shiftop .)
    ,               reduce using rule 87 (prod -> prod / shiftop .)
    ]               reduce using rule 87 (prod -> prod / shiftop .)
    }               reduce using rule 87 (prod -> prod / shiftop .)
    SHIFT_L         shift and go to state 115
    SHIFT_R         shift and go to state 116


state 158

    (88) prod -> prod * shiftop .
    (90) shiftop -> shiftop . SHIFT_L unary
    (91) shiftop -> shiftop . SHIFT_R unary
    /               reduce using rule 88 (prod -> prod * shiftop .)
    *               reduce using rule 88 (prod -> prod * shiftop .)
    <               reduce using rule 88 (prod -> prod * shiftop .)
    >               reduce using rule 88 (prod -> prod * shiftop .)
    GREATER_EQ      reduce using rule 88 (prod -> prod * shiftop .)
    LESSER_EQ       reduce using rule 88 (prod -> prod * shiftop .)
    NOT_EQ          reduce using rule 88 (prod -> prod * shiftop .)
    EQ_EQ           reduce using rule 88 (prod -> prod * shiftop .)
    -               reduce using rule 88 (prod -> prod * shiftop .)
    +               reduce using rule 88 (prod -> prod * shiftop .)
    &               reduce using rule 88 (prod -> prod * shiftop .)
    ^               reduce using rule 88 (prod -> prod * shiftop .)
    |               reduce using rule 88 (prod -> prod * shiftop .)
    AND             reduce using rule 88 (prod -> prod * shiftop .)
    OR              reduce using rule 88 (prod -> prod * shiftop .)
    ;               reduce using rule 88 (prod -> prod * shiftop .)
    )               reduce using rule 88 (prod -> prod * shiftop .)
    ,               reduce using rule 88 (prod -> prod * shiftop .)
    ]               reduce using rule 88 (prod -> prod * shiftop .)
    }               reduce using rule 88 (prod -> prod * shiftop .)
    SHIFT_L         shift and go to state 115
    SHIFT_R         shift and go to state 116


state 159

    (90) shiftop -> shiftop SHIFT_L unary .
    SHIFT_L         reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    SHIFT_R         reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    /               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    *               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    <               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    >               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    GREATER_EQ      reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    LESSER_EQ       reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    NOT_EQ          reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    EQ_EQ           reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    -               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    +               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    &               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    ^               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    |               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    AND             reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    OR              reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    ;               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    )               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    ,               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    ]               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)
    }               reduce using rule 90 (shiftop -> shiftop SHIFT_L unary .)


state 160

    (91) shiftop -> shiftop SHIFT_R unary .
    SHIFT_L         reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    SHIFT_R         reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    /               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    *               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    <               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    >               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    GREATER_EQ      reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    LESSER_EQ       reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    NOT_EQ          reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    EQ_EQ           reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    -               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    +               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    &               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    ^               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    |               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    AND             reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    OR              reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    ;               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    )               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    ,               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    ]               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)
    }               reduce using rule 91 (shiftop -> shiftop SHIFT_R unary .)


state 161

    (13) fun_args_ -> type decl_ptrs ID .
    ,               reduce using rule 13 (fun_args_ -> type decl_ptrs ID .)
    )               reduce using rule 13 (fun_args_ -> type decl_ptrs ID .)


state 162

    (14) fun_args_ -> fun_args_ , type . decl_ptrs ID
    (50) decl_ptrs -> .
    (51) decl_ptrs -> . decl_ptrs *
    ID              reduce using rule 50 (decl_ptrs -> .)
    *               reduce using rule 50 (decl_ptrs -> .)

    decl_ptrs                      shift and go to state 181

state 163

    (56) array_idxs -> array_idxs [ NUM ] .
    [               reduce using rule 56 (array_idxs -> array_idxs [ NUM ] .)
    =               reduce using rule 56 (array_idxs -> array_idxs [ NUM ] .)
    ;               reduce using rule 56 (array_idxs -> array_idxs [ NUM ] .)
    ,               reduce using rule 56 (array_idxs -> array_idxs [ NUM ] .)


state 164

    (57) array -> { array_base . }
    (62) array_base -> array_base . , exp
    }               shift and go to state 182
    ,               shift and go to state 183


state 165

    (58) array -> { array_rec . }
    (60) array_rec -> array_rec . , array
    }               shift and go to state 184
    ,               shift and go to state 185


state 166

    (61) array_base -> exp .
    }               reduce using rule 61 (array_base -> exp .)
    ,               reduce using rule 61 (array_base -> exp .)


state 167

    (59) array_rec -> array .
    }               reduce using rule 59 (array_rec -> array .)
    ,               reduce using rule 59 (array_rec -> array .)


state 168

    (29) for_stmt -> KW_FOR ( for_decl for_cond . for_exp ) block_stmt
    (34) for_exp -> .
    (35) for_exp -> . exp
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    )               reduce using rule 34 (for_exp -> .)
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    for_exp                        shift and go to state 186
    exp                            shift and go to state 187
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 169

    (32) for_cond -> ; .
    (               reduce using rule 32 (for_cond -> ; .)
    ~               reduce using rule 32 (for_cond -> ; .)
    &               reduce using rule 32 (for_cond -> ; .)
    *               reduce using rule 32 (for_cond -> ; .)
    -               reduce using rule 32 (for_cond -> ; .)
    !               reduce using rule 32 (for_cond -> ; .)
    ID              reduce using rule 32 (for_cond -> ; .)
    STR             reduce using rule 32 (for_cond -> ; .)
    NUM_LIT         reduce using rule 32 (for_cond -> ; .)
    NUM             reduce using rule 32 (for_cond -> ; .)
    KW_SIZEOF       reduce using rule 32 (for_cond -> ; .)
    )               reduce using rule 32 (for_cond -> ; .)


state 170

    (33) for_cond -> exp . ;
    ;               shift and go to state 188


state 171

    (93) unary -> ( type_lit ) unary .
    =               reduce using rule 93 (unary -> ( type_lit ) unary .)
    SHIFT_L         reduce using rule 93 (unary -> ( type_lit ) unary .)
    SHIFT_R         reduce using rule 93 (unary -> ( type_lit ) unary .)
    /               reduce using rule 93 (unary -> ( type_lit ) unary .)
    *               reduce using rule 93 (unary -> ( type_lit ) unary .)
    <               reduce using rule 93 (unary -> ( type_lit ) unary .)
    >               reduce using rule 93 (unary -> ( type_lit ) unary .)
    GREATER_EQ      reduce using rule 93 (unary -> ( type_lit ) unary .)
    LESSER_EQ       reduce using rule 93 (unary -> ( type_lit ) unary .)
    NOT_EQ          reduce using rule 93 (unary -> ( type_lit ) unary .)
    EQ_EQ           reduce using rule 93 (unary -> ( type_lit ) unary .)
    -               reduce using rule 93 (unary -> ( type_lit ) unary .)
    +               reduce using rule 93 (unary -> ( type_lit ) unary .)
    &               reduce using rule 93 (unary -> ( type_lit ) unary .)
    ^               reduce using rule 93 (unary -> ( type_lit ) unary .)
    |               reduce using rule 93 (unary -> ( type_lit ) unary .)
    AND             reduce using rule 93 (unary -> ( type_lit ) unary .)
    OR              reduce using rule 93 (unary -> ( type_lit ) unary .)
    ;               reduce using rule 93 (unary -> ( type_lit ) unary .)
    )               reduce using rule 93 (unary -> ( type_lit ) unary .)
    ,               reduce using rule 93 (unary -> ( type_lit ) unary .)
    ]               reduce using rule 93 (unary -> ( type_lit ) unary .)
    }               reduce using rule 93 (unary -> ( type_lit ) unary .)


state 172

    (114) type_lit -> type_lit [ NUM . ]
    ]               shift and go to state 189


state 173

    (26) while_stmt -> KW_WHILE ( exp ) . block_stmt
    (43) block_stmt -> . { body }
    {               shift and go to state 25

    block_stmt                     shift and go to state 190

state 174

    (36) if_stmt -> KW_IF ( exp ) . block_stmt else_stmt
    (43) block_stmt -> . { body }
    {               shift and go to state 25

    block_stmt                     shift and go to state 191

state 175

    (44) var_decl -> is_static type var_decl_ ; .
    }               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_FOR          reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_CONTINUE     reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_BREAK        reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_WHILE        reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    {               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_IF           reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_RETURN       reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_STATIC       reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    (               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    ~               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    &               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    *               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    -               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    !               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    ID              reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    STR             reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    NUM_LIT         reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    NUM             reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_SIZEOF       reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_VOID         reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    KW_INT          reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)
    ;               reduce using rule 44 (var_decl -> is_static type var_decl_ ; .)


state 176

    (100) call -> call [ exp ] .
    [               reduce using rule 100 (call -> call [ exp ] .)
    =               reduce using rule 100 (call -> call [ exp ] .)
    SHIFT_L         reduce using rule 100 (call -> call [ exp ] .)
    SHIFT_R         reduce using rule 100 (call -> call [ exp ] .)
    /               reduce using rule 100 (call -> call [ exp ] .)
    *               reduce using rule 100 (call -> call [ exp ] .)
    <               reduce using rule 100 (call -> call [ exp ] .)
    >               reduce using rule 100 (call -> call [ exp ] .)
    GREATER_EQ      reduce using rule 100 (call -> call [ exp ] .)
    LESSER_EQ       reduce using rule 100 (call -> call [ exp ] .)
    NOT_EQ          reduce using rule 100 (call -> call [ exp ] .)
    EQ_EQ           reduce using rule 100 (call -> call [ exp ] .)
    -               reduce using rule 100 (call -> call [ exp ] .)
    +               reduce using rule 100 (call -> call [ exp ] .)
    &               reduce using rule 100 (call -> call [ exp ] .)
    ^               reduce using rule 100 (call -> call [ exp ] .)
    |               reduce using rule 100 (call -> call [ exp ] .)
    AND             reduce using rule 100 (call -> call [ exp ] .)
    OR              reduce using rule 100 (call -> call [ exp ] .)
    ;               reduce using rule 100 (call -> call [ exp ] .)
    )               reduce using rule 100 (call -> call [ exp ] .)
    ,               reduce using rule 100 (call -> call [ exp ] .)
    ]               reduce using rule 100 (call -> call [ exp ] .)
    }               reduce using rule 100 (call -> call [ exp ] .)


state 177

    (101) call -> ID ( call_args ) .
    [               reduce using rule 101 (call -> ID ( call_args ) .)
    =               reduce using rule 101 (call -> ID ( call_args ) .)
    SHIFT_L         reduce using rule 101 (call -> ID ( call_args ) .)
    SHIFT_R         reduce using rule 101 (call -> ID ( call_args ) .)
    /               reduce using rule 101 (call -> ID ( call_args ) .)
    *               reduce using rule 101 (call -> ID ( call_args ) .)
    <               reduce using rule 101 (call -> ID ( call_args ) .)
    >               reduce using rule 101 (call -> ID ( call_args ) .)
    GREATER_EQ      reduce using rule 101 (call -> ID ( call_args ) .)
    LESSER_EQ       reduce using rule 101 (call -> ID ( call_args ) .)
    NOT_EQ          reduce using rule 101 (call -> ID ( call_args ) .)
    EQ_EQ           reduce using rule 101 (call -> ID ( call_args ) .)
    -               reduce using rule 101 (call -> ID ( call_args ) .)
    +               reduce using rule 101 (call -> ID ( call_args ) .)
    &               reduce using rule 101 (call -> ID ( call_args ) .)
    ^               reduce using rule 101 (call -> ID ( call_args ) .)
    |               reduce using rule 101 (call -> ID ( call_args ) .)
    AND             reduce using rule 101 (call -> ID ( call_args ) .)
    OR              reduce using rule 101 (call -> ID ( call_args ) .)
    ;               reduce using rule 101 (call -> ID ( call_args ) .)
    )               reduce using rule 101 (call -> ID ( call_args ) .)
    ,               reduce using rule 101 (call -> ID ( call_args ) .)
    ]               reduce using rule 101 (call -> ID ( call_args ) .)
    }               reduce using rule 101 (call -> ID ( call_args ) .)


state 178

    (105) call_args_ -> call_args_ , . exp
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    exp                            shift and go to state 192
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 179

    (110) atom -> KW_SIZEOF ( type_lit ) .
    [               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    =               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    SHIFT_L         reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    SHIFT_R         reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    /               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    *               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    <               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    >               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    GREATER_EQ      reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    LESSER_EQ       reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    NOT_EQ          reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    EQ_EQ           reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    -               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    +               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    &               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    ^               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    |               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    AND             reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    OR              reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    ;               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    )               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    ,               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    ]               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)
    }               reduce using rule 110 (atom -> KW_SIZEOF ( type_lit ) .)


state 180

    (111) atom -> KW_SIZEOF ( exp ) .
    [               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    =               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    SHIFT_L         reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    SHIFT_R         reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    /               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    *               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    <               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    >               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    GREATER_EQ      reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    LESSER_EQ       reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    NOT_EQ          reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    EQ_EQ           reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    -               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    +               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    &               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    ^               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    |               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    AND             reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    OR              reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    ;               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    )               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    ,               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    ]               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)
    }               reduce using rule 111 (atom -> KW_SIZEOF ( exp ) .)


state 181

    (14) fun_args_ -> fun_args_ , type decl_ptrs . ID
    (51) decl_ptrs -> decl_ptrs . *
    ID              shift and go to state 193
    *               shift and go to state 19


state 182

    (57) array -> { array_base } .
    ;               reduce using rule 57 (array -> { array_base } .)
    ,               reduce using rule 57 (array -> { array_base } .)
    }               reduce using rule 57 (array -> { array_base } .)


state 183

    (62) array_base -> array_base , . exp
    (63) exp -> . assign
    (64) assign -> . or_exp
    (65) assign -> . unary = assign
    (66) or_exp -> . and_exp
    (67) or_exp -> . or_exp OR and_exp
    (92) unary -> . call
    (93) unary -> . ( type_lit ) unary
    (94) unary -> . ~ unary
    (95) unary -> . & unary
    (96) unary -> . * unary
    (97) unary -> . - unary
    (98) unary -> . ! unary
    (68) and_exp -> . or_bin
    (69) and_exp -> . and_exp AND or_bin
    (99) call -> . atom
    (100) call -> . call [ exp ]
    (101) call -> . ID ( call_args )
    (70) or_bin -> . xor_bin ^ and_bin
    (71) or_bin -> . or_bin | xor_bin
    (106) atom -> . STR
    (107) atom -> . NUM_LIT
    (108) atom -> . NUM
    (109) atom -> . ID
    (110) atom -> . KW_SIZEOF ( type_lit )
    (111) atom -> . KW_SIZEOF ( exp )
    (112) atom -> . ( exp )
    (72) xor_bin -> . and_bin
    (73) xor_bin -> . xor_bin
    (74) and_bin -> . comp_exp
    (75) and_bin -> . and_bin & comp_exp
    (76) comp_exp -> . sum
    (77) comp_exp -> . sum < comp_exp
    (78) comp_exp -> . sum > comp_exp
    (79) comp_exp -> . sum GREATER_EQ comp_exp
    (80) comp_exp -> . sum LESSER_EQ comp_exp
    (81) comp_exp -> . sum NOT_EQ comp_exp
    (82) comp_exp -> . sum EQ_EQ comp_exp
    (83) sum -> . prod
    (84) sum -> . sum - prod
    (85) sum -> . sum + prod
    (86) prod -> . shiftop
    (87) prod -> . prod / shiftop
    (88) prod -> . prod * shiftop
    (89) shiftop -> . unary
    (90) shiftop -> . shiftop SHIFT_L unary
    (91) shiftop -> . shiftop SHIFT_R unary
    (               shift and go to state 38
    ~               shift and go to state 52
    &               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    !               shift and go to state 56
    ID              shift and go to state 59
    STR             shift and go to state 62
    NUM_LIT         shift and go to state 63
    NUM             shift and go to state 64
    KW_SIZEOF       shift and go to state 65

    exp                            shift and go to state 194
    assign                         shift and go to state 47
    or_exp                         shift and go to state 48
    unary                          shift and go to state 49
    and_exp                        shift and go to state 50
    call                           shift and go to state 51
    or_bin                         shift and go to state 57
    atom                           shift and go to state 58
    xor_bin                        shift and go to state 60
    and_bin                        shift and go to state 61
    comp_exp                       shift and go to state 66
    sum                            shift and go to state 67
    prod                           shift and go to state 68
    shiftop                        shift and go to state 69

state 184

    (58) array -> { array_rec } .
    ;               reduce using rule 58 (array -> { array_rec } .)
    ,               reduce using rule 58 (array -> { array_rec } .)
    }               reduce using rule 58 (array -> { array_rec } .)


state 185

    (60) array_rec -> array_rec , . array
    (57) array -> . { array_base }
    (58) array -> . { array_rec }
    {               shift and go to state 123

    array                          shift and go to state 195

state 186

    (29) for_stmt -> KW_FOR ( for_decl for_cond for_exp . ) block_stmt
    )               shift and go to state 196


state 187

    (35) for_exp -> exp .
    )               reduce using rule 35 (for_exp -> exp .)


state 188

    (33) for_cond -> exp ; .
    (               reduce using rule 33 (for_cond -> exp ; .)
    ~               reduce using rule 33 (for_cond -> exp ; .)
    &               reduce using rule 33 (for_cond -> exp ; .)
    *               reduce using rule 33 (for_cond -> exp ; .)
    -               reduce using rule 33 (for_cond -> exp ; .)
    !               reduce using rule 33 (for_cond -> exp ; .)
    ID              reduce using rule 33 (for_cond -> exp ; .)
    STR             reduce using rule 33 (for_cond -> exp ; .)
    NUM_LIT         reduce using rule 33 (for_cond -> exp ; .)
    NUM             reduce using rule 33 (for_cond -> exp ; .)
    KW_SIZEOF       reduce using rule 33 (for_cond -> exp ; .)
    )               reduce using rule 33 (for_cond -> exp ; .)


state 189

    (114) type_lit -> type_lit [ NUM ] .
    )               reduce using rule 114 (type_lit -> type_lit [ NUM ] .)
    [               reduce using rule 114 (type_lit -> type_lit [ NUM ] .)


state 190

    (26) while_stmt -> KW_WHILE ( exp ) block_stmt .
    }               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_FOR          reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_CONTINUE     reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_BREAK        reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_WHILE        reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    {               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_IF           reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_RETURN       reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_STATIC       reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    (               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    ~               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    &               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    *               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    -               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    !               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    ID              reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    STR             reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    NUM_LIT         reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    NUM             reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_SIZEOF       reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_VOID         reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    KW_INT          reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)
    ;               reduce using rule 26 (while_stmt -> KW_WHILE ( exp ) block_stmt .)


state 191

    (36) if_stmt -> KW_IF ( exp ) block_stmt . else_stmt
    (37) else_stmt -> .
    (38) else_stmt -> . KW_ELSE if_stmt
    (39) else_stmt -> . KW_ELSE block_stmt
    }               reduce using rule 37 (else_stmt -> .)
    KW_FOR          reduce using rule 37 (else_stmt -> .)
    KW_CONTINUE     reduce using rule 37 (else_stmt -> .)
    KW_BREAK        reduce using rule 37 (else_stmt -> .)
    KW_WHILE        reduce using rule 37 (else_stmt -> .)
    {               reduce using rule 37 (else_stmt -> .)
    KW_IF           reduce using rule 37 (else_stmt -> .)
    KW_RETURN       reduce using rule 37 (else_stmt -> .)
    KW_STATIC       reduce using rule 37 (else_stmt -> .)
    (               reduce using rule 37 (else_stmt -> .)
    ~               reduce using rule 37 (else_stmt -> .)
    &               reduce using rule 37 (else_stmt -> .)
    *               reduce using rule 37 (else_stmt -> .)
    -               reduce using rule 37 (else_stmt -> .)
    !               reduce using rule 37 (else_stmt -> .)
    ID              reduce using rule 37 (else_stmt -> .)
    STR             reduce using rule 37 (else_stmt -> .)
    NUM_LIT         reduce using rule 37 (else_stmt -> .)
    NUM             reduce using rule 37 (else_stmt -> .)
    KW_SIZEOF       reduce using rule 37 (else_stmt -> .)
    KW_VOID         reduce using rule 37 (else_stmt -> .)
    KW_INT          reduce using rule 37 (else_stmt -> .)
    ;               reduce using rule 37 (else_stmt -> .)
    KW_ELSE         shift and go to state 198

    else_stmt                      shift and go to state 197

state 192

    (105) call_args_ -> call_args_ , exp .
    ,               reduce using rule 105 (call_args_ -> call_args_ , exp .)
    )               reduce using rule 105 (call_args_ -> call_args_ , exp .)


state 193

    (14) fun_args_ -> fun_args_ , type decl_ptrs ID .
    ,               reduce using rule 14 (fun_args_ -> fun_args_ , type decl_ptrs ID .)
    )               reduce using rule 14 (fun_args_ -> fun_args_ , type decl_ptrs ID .)


state 194

    (62) array_base -> array_base , exp .
    }               reduce using rule 62 (array_base -> array_base , exp .)
    ,               reduce using rule 62 (array_base -> array_base , exp .)


state 195

    (60) array_rec -> array_rec , array .
    }               reduce using rule 60 (array_rec -> array_rec , array .)
    ,               reduce using rule 60 (array_rec -> array_rec , array .)


state 196

    (29) for_stmt -> KW_FOR ( for_decl for_cond for_exp ) . block_stmt
    (43) block_stmt -> . { body }
    {               shift and go to state 25

    block_stmt                     shift and go to state 199

state 197

    (36) if_stmt -> KW_IF ( exp ) block_stmt else_stmt .
    }               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_FOR          reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_CONTINUE     reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_BREAK        reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_WHILE        reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    {               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_IF           reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_RETURN       reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_STATIC       reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    (               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    ~               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    &               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    *               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    -               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    !               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    ID              reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    STR             reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    NUM_LIT         reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    NUM             reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_SIZEOF       reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_VOID         reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    KW_INT          reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)
    ;               reduce using rule 36 (if_stmt -> KW_IF ( exp ) block_stmt else_stmt .)


state 198

    (38) else_stmt -> KW_ELSE . if_stmt
    (39) else_stmt -> KW_ELSE . block_stmt
    (36) if_stmt -> . KW_IF ( exp ) block_stmt else_stmt
    (43) block_stmt -> . { body }
    KW_IF           shift and go to state 43
    {               shift and go to state 25

    if_stmt                        shift and go to state 200
    block_stmt                     shift and go to state 201

state 199

    (29) for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .
    }               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_FOR          reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_CONTINUE     reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_BREAK        reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_WHILE        reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    {               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_IF           reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_RETURN       reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_STATIC       reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    (               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    ~               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    &               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    *               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    -               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    !               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    ID              reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    STR             reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    NUM_LIT         reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    NUM             reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_SIZEOF       reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_VOID         reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    KW_INT          reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)
    ;               reduce using rule 29 (for_stmt -> KW_FOR ( for_decl for_cond for_exp ) block_stmt .)


state 200

    (38) else_stmt -> KW_ELSE if_stmt .
    }               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_FOR          reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_CONTINUE     reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_BREAK        reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_WHILE        reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    {               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_IF           reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_RETURN       reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_STATIC       reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    (               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    ~               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    &               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    *               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    -               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    !               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    ID              reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    STR             reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    NUM_LIT         reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    NUM             reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_SIZEOF       reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_VOID         reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    KW_INT          reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)
    ;               reduce using rule 38 (else_stmt -> KW_ELSE if_stmt .)


state 201

    (39) else_stmt -> KW_ELSE block_stmt .
    }               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_FOR          reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_CONTINUE     reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_BREAK        reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_WHILE        reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    {               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_IF           reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_RETURN       reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_STATIC       reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    (               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    ~               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    &               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    *               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    -               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    !               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    ID              reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    STR             reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    NUM_LIT         reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    NUM             reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_SIZEOF       reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_VOID         reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    KW_INT          reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)
    ;               reduce using rule 39 (else_stmt -> KW_ELSE block_stmt .)


Conflicts:

shift/reduce conflict for ^ in state 60 resolved as shift
reduce/reduce conflict in state 141 resolved using rule or_bin -> or_bin | xor_bin
rejected rule (xor_bin -> xor_bin) in state 141
Rule (xor_bin -> xor_bin) is never reduced
